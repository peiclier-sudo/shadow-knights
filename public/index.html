<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shadow Knights - SIMPLE VERSION</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            overflow: hidden;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        html, body {
            width: 100%;
            height: 100%;
            position: fixed;
            overflow: hidden;
        }
        body {
            background: radial-gradient(circle at center, #1a0a2e 0%, #000000 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', monospace;
        }
        #game-container { 
            width: 100vw;
            height: 100vh;
            max-width: 100%;
            max-height: 100%;
            box-shadow: 0 0 80px rgba(0,212,255,0.6), 0 0 40px rgba(255,0,80,0.4);
            border: 2px solid rgba(0,212,255,0.2);
        }
        /* Hide address bar on mobile */
        @media (max-width: 900px) {
            body {
                width: 100vw;
                height: 100vh;
                position: fixed;
                overflow: hidden;
            }
            #game-container {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                border: none;
                box-shadow: none;
            }
        }
        @media (max-width: 900px) and (orientation: portrait) {
            body::before {
                content: "üì± ROTATE TO LANDSCAPE";
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: #00d4ff;
                font-size: 28px;
                font-weight: bold;
                text-shadow: 0 0 20px #00d4ff;
                z-index: 9999;
                text-align: center;
            }
            #game-container { display: none; }
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
        const config = {
            type: Phaser.AUTO,
            width: 1000,
            height: 700,
            parent: 'game-container',
            backgroundColor: '#0a0a14',
            physics: { default: 'arcade', arcade: { gravity: { y: 0 }}},
            scene: { create, update },
            scale: { 
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH,
                width: 1000,
                height: 700
            },
            render: {
                pixelArt: false,
                antialias: true,
                roundPixels: false
            }
        };

        // BOSS DATA
        const BOSSES = {
            1: { name: 'SENTINEL', hp: 400, color: 0xff0051 },
            2: { name: 'GUNNER', hp: 500, color: 0xff6600 },
            3: { name: 'DASHER', hp: 600, color: 0xcc00ff }
        };
        
        let currentBossId = parseInt(localStorage.getItem('currentBoss')) || 1;
        let unlockedBosses = parseInt(localStorage.getItem('unlockedBosses')) || 1;

        let game, player, boss;
        let playerHealth = 100, bossHealth = BOSSES[currentBossId].hp, playerStamina = 100;
        let isDodging = false, canDodge = true, canAttack = true;
        let playerHealthBar, bossHealthBar, staminaBar, playerHealthText, bossHealthText, staminaText;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let bossNextAttackTime = 0;
        
        // Mobile controls
        let moveJoy = { active: false, deltaX: 0, deltaY: 0 };
        let aimJoy = { active: false, angle: 0 };
        let projectiles = [];
        let bossProjectiles = [];
        
        // Desktop controls
        let leftMouseDown = false;
        let rightMouseDown = false;
        let mouseX = 0, mouseY = 0;
        let aimStartX = 0, aimStartY = 0;
        let aimIndicator = null;

        // Hide mobile browser UI
        if (isMobile) {
            // Fullscreen on mobile
            window.addEventListener('load', () => {
                setTimeout(() => {
                    window.scrollTo(0, 1);
                }, 100);
            });
            
            // Prevent pull-to-refresh
            document.body.addEventListener('touchmove', (e) => {
                if (e.target === document.body) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Hide address bar on scroll
            let lastScrollTop = 0;
            window.addEventListener('scroll', () => {
                const st = window.pageYOffset || document.documentElement.scrollTop;
                if (st > lastScrollTop) {
                    window.scrollTo(0, 1);
                }
                lastScrollTop = st <= 0 ? 0 : st;
            }, false);
        }

        function create() {
            // Grille NEON anim√©e
            const bossData = BOSSES[currentBossId];
            const g = this.add.graphics();
            g.lineStyle(1, bossData.color, 0.15);
            for (let i = 0; i < 1000; i += 50) g.lineBetween(i, 0, i, 700);
            for (let i = 0; i < 700; i += 50) g.lineBetween(0, i, 1000, i);
            
            // Particles ambiantes
            for (let i = 0; i < 50; i++) {
                const x = Phaser.Math.Between(0, 1000);
                const y = Phaser.Math.Between(0, 700);
                const size = Phaser.Math.Between(1, 3);
                const color = Phaser.Math.RND.pick([0x00d4ff, bossData.color]);
                const particle = this.add.circle(x, y, size, color, 0.5);
                
                this.tweens.add({
                    targets: particle,
                    y: y + Phaser.Math.Between(-30, 30),
                    alpha: 0.2,
                    duration: Phaser.Math.Between(2000, 4000),
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            }

            // Joueur avec GLOW
            player = this.add.circle(150, 350, 20, 0x00d4ff);
            this.physics.add.existing(player);
            player.body.setCollideWorldBounds(true);
            
            // Double glow effect
            player.glow1 = this.add.circle(150, 350, 40, 0x00d4ff, 0.4);
            player.glow2 = this.add.circle(150, 350, 60, 0x00d4ff, 0.2);
            
            this.tweens.add({
                targets: player.glow1,
                scale: 1.3,
                alpha: 0.15,
                duration: 1200,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
            
            this.tweens.add({
                targets: player.glow2,
                scale: 1.5,
                alpha: 0.05,
                duration: 1800,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });

            // Boss - Diff√©rent selon ID avec GLOW
            const bossData = BOSSES[currentBossId];
            boss = this.add.container(850, 350);
            
            if (currentBossId === 1) {
                // Sentinel: Rectangle + circle
                boss.add([
                    this.add.rectangle(0, 0, 70, 100, bossData.color),
                    this.add.circle(0, -60, 30, bossData.color)
                ]);
            } else if (currentBossId === 2) {
                // Gunner: Star/Hexagon
                boss.add([
                    this.add.star(0, 0, 6, 20, 40, bossData.color),
                    this.add.circle(0, 0, 12, 0xffffff)
                ]);
            } else if (currentBossId === 3) {
                // Dasher: Triangle
                const tri = this.add.triangle(0, 0, 0, -40, -35, 35, 35, 35, bossData.color);
                boss.add(tri);
            }
            
            this.physics.add.existing(boss);
            boss.body.setSize(70, 130);
            boss.body.setCollideWorldBounds(true);
            boss.body.immovable = true;
            
            // Boss glow pulsant
            boss.glow1 = this.add.circle(850, 350, 90, bossData.color, 0.3);
            boss.glow2 = this.add.circle(850, 350, 120, bossData.color, 0.15);
            boss.glow1.setDepth(-1);
            boss.glow2.setDepth(-2);
            
            this.tweens.add({
                targets: boss.glow1,
                scale: 1.2,
                alpha: 0.1,
                duration: 1500,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
            
            this.tweens.add({
                targets: boss.glow2,
                scale: 1.4,
                alpha: 0.05,
                duration: 2000,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });

            // UI
            this.add.text(500, 30, bossData.name, { fontSize: '28px', fill: '#' + bossData.color.toString(16).padStart(6, '0'), fontStyle: 'bold' }).setOrigin(0.5);
            
            this.add.text(20, 20, 'VOUS', { fontSize: '18px', fill: '#00d4ff', fontStyle: 'bold' });
            playerHealthBar = this.add.rectangle(20, 55, 350, 25, 0x1a1a2e).setOrigin(0, 0.5).setStrokeStyle(3, 0x333355);
            playerHealthText = this.add.rectangle(20, 55, 350, 25, 0x00ff88).setOrigin(0, 0.5);
            
            this.add.text(20, 82, 'STAMINA', { fontSize: '14px', fill: '#ffaa00' });
            staminaBar = this.add.rectangle(20, 105, 250, 16, 0x1a1a2e).setOrigin(0, 0.5).setStrokeStyle(2, 0x333355);
            staminaText = this.add.rectangle(20, 105, 250, 16, 0xffaa00).setOrigin(0, 0.5);

            this.add.text(650, 70, 'BOSS', { fontSize: '14px', fill: '#' + bossData.color.toString(16).padStart(6, '0') });
            bossHealthBar = this.add.rectangle(650, 95, 330, 28, 0x1a1a2e).setOrigin(0, 0.5).setStrokeStyle(3, 0x333355);
            bossHealthText = this.add.rectangle(650, 95, 330, 28, bossData.color).setOrigin(0, 0.5);

            if (isMobile) createMobileControls(this);
            else createDesktopControls(this);

            const instructions = isMobile ? 'Gauche: Bouger | Droite: Tirer' 
                : 'Clic Gauche: Aller vers souris | Clic Droit: Viser & Tirer';
            this.add.text(500, 680, instructions, { fontSize: '13px', fill: '#aaa', backgroundColor: '#00000099', padding: { x: 15, y: 8 }}).setOrigin(0.5);
        }

        function createDesktopControls(scene) {
            // Indicateur de vis√©e
            aimIndicator = scene.add.graphics();
            aimIndicator.setDepth(500);
            
            // D√©sactiver menu contextuel
            scene.input.mouse.disableContextMenu();
            
            // CLIC GAUCHE = MOUVEMENT vers la souris
            scene.input.on('pointerdown', (pointer) => {
                if (pointer.leftButtonDown()) {
                    leftMouseDown = true;
                    mouseX = pointer.x;
                    mouseY = pointer.y;
                }
                
                if (pointer.rightButtonDown()) {
                    rightMouseDown = true;
                    aimStartX = player.x;
                    aimStartY = player.y;
                    mouseX = pointer.x;
                    mouseY = pointer.y;
                }
            });
            
            scene.input.on('pointermove', (pointer) => {
                mouseX = pointer.x;
                mouseY = pointer.y;
            });
            
            scene.input.on('pointerup', (pointer) => {
                if (pointer.button === 0) { // Left button
                    leftMouseDown = false;
                }
                
                if (pointer.button === 2) { // Right button
                    if (rightMouseDown && canAttack && playerStamina >= 20) {
                        const angle = Math.atan2(mouseY - aimStartY, mouseX - aimStartX);
                        shootProjectile(scene, angle);
                    }
                    rightMouseDown = false;
                }
            });
        }

        function createMobileControls(scene) {
            // Zones
            const leftZone = scene.add.rectangle(250, 350, 500, 700, 0x0066ff, 0.1);
            const rightZone = scene.add.rectangle(750, 350, 500, 700, 0xff6666, 0.1);
            scene.add.text(250, 50, '‚¨ÖÔ∏è BOUGER', { fontSize: '18px', fill: '#00d4ff', fontStyle: 'bold' }).setOrigin(0.5);
            scene.add.text(750, 50, 'TIRER ‚û°Ô∏è', { fontSize: '18px', fill: '#ff6666', fontStyle: 'bold' }).setOrigin(0.5);
            
            let leftTouch = null, rightTouch = null;
            
            scene.input.addPointer(3);
            
            scene.input.on('pointerdown', (pointer) => {
                if (pointer.x < 500 && !leftTouch) {
                    leftTouch = {
                        id: pointer.id,
                        startX: pointer.x,
                        startY: pointer.y,
                        base: scene.add.circle(pointer.x, pointer.y, 55, 0x0033aa, 0.7).setDepth(300),
                        thumb: scene.add.circle(pointer.x, pointer.y, 28, 0x00d4ff, 1).setDepth(301)
                    };
                }
                
                if (pointer.x >= 500 && !rightTouch) {
                    rightTouch = {
                        id: pointer.id,
                        startX: pointer.x,
                        startY: pointer.y,
                        base: scene.add.circle(pointer.x, pointer.y, 55, 0xaa3300, 0.7).setDepth(300),
                        thumb: scene.add.circle(pointer.x, pointer.y, 28, 0xff6666, 1).setDepth(301)
                    };
                }
            });
            
            scene.input.on('pointermove', (pointer) => {
                if (!pointer.isDown) return;
                
                if (leftTouch && pointer.id === leftTouch.id) {
                    const dx = pointer.x - leftTouch.startX;
                    const dy = pointer.y - leftTouch.startY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const max = 55;
                    
                    if (dist < max) {
                        leftTouch.thumb.x = leftTouch.startX + dx;
                        leftTouch.thumb.y = leftTouch.startY + dy;
                        moveJoy.deltaX = dx / max;
                        moveJoy.deltaY = dy / max;
                    } else {
                        const angle = Math.atan2(dy, dx);
                        leftTouch.thumb.x = leftTouch.startX + Math.cos(angle) * max;
                        leftTouch.thumb.y = leftTouch.startY + Math.sin(angle) * max;
                        moveJoy.deltaX = Math.cos(angle);
                        moveJoy.deltaY = Math.sin(angle);
                    }
                    moveJoy.active = true;
                }
                
                if (rightTouch && pointer.id === rightTouch.id) {
                    const dx = pointer.x - rightTouch.startX;
                    const dy = pointer.y - rightTouch.startY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const max = 55;
                    
                    if (dist < max) {
                        rightTouch.thumb.x = rightTouch.startX + dx;
                        rightTouch.thumb.y = rightTouch.startY + dy;
                    } else {
                        const angle = Math.atan2(dy, dx);
                        rightTouch.thumb.x = rightTouch.startX + Math.cos(angle) * max;
                        rightTouch.thumb.y = rightTouch.startY + Math.sin(angle) * max;
                    }
                    
                    aimJoy.angle = Math.atan2(dy, dx);
                    aimJoy.active = dist > 15;
                }
            });
            
            scene.input.on('pointerup', (pointer) => {
                if (leftTouch && pointer.id === leftTouch.id) {
                    leftTouch.base.destroy();
                    leftTouch.thumb.destroy();
                    leftTouch = null;
                    moveJoy.active = false;
                    moveJoy.deltaX = 0;
                    moveJoy.deltaY = 0;
                }
                
                if (rightTouch && pointer.id === rightTouch.id) {
                    if (aimJoy.active && canAttack && playerStamina >= 20) {
                        shootProjectile(scene, aimJoy.angle);
                    }
                    rightTouch.base.destroy();
                    rightTouch.thumb.destroy();
                    rightTouch = null;
                    aimJoy.active = false;
                }
            });
        }

        function update(time, delta) {
            if (playerHealth <= 0 || bossHealth <= 0) {
                handleGameOver(this);
                return;
            }

            // Mouvement
            const speed = 220;
            let vx = 0, vy = 0;
            
            // MOBILE: Joystick
            if (isMobile && moveJoy.active) {
                vx = moveJoy.deltaX * speed;
                vy = moveJoy.deltaY * speed;
            }
            
            // DESKTOP: Point-and-click avec clic gauche
            if (!isMobile && leftMouseDown) {
                const dx = mouseX - player.x;
                const dy = mouseY - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 10) { // Deadzone
                    const angle = Math.atan2(dy, dx);
                    vx = Math.cos(angle) * speed;
                    vy = Math.sin(angle) * speed;
                    
                    // Ralentir quand proche de la cible
                    if (dist < 50) {
                        vx *= (dist / 50);
                        vy *= (dist / 50);
                    }
                }
            }
            
            player.body.setVelocity(vx, vy);
            
            // Sync player glows
            if (player.glow1) {
                player.glow1.x = player.x;
                player.glow1.y = player.y;
            }
            if (player.glow2) {
                player.glow2.x = player.x;
                player.glow2.y = player.y;
            }
            
            // Sync boss glows
            if (boss.glow1) {
                boss.glow1.x = boss.x;
                boss.glow1.y = boss.y;
            }
            if (boss.glow2) {
                boss.glow2.x = boss.x;
                boss.glow2.y = boss.y;
            }
            
            // Indicateur de vis√©e (desktop clic droit)
            if (!isMobile && aimIndicator) {
                aimIndicator.clear();
                
                if (rightMouseDown) {
                    const dx = mouseX - aimStartX;
                    const dy = mouseY - aimStartY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 15) {
                        // Ligne de vis√©e
                        aimIndicator.lineStyle(3, 0xff6666, 0.8);
                        for (let i = 0; i < dist; i += 15) {
                            const x1 = aimStartX + (dx / dist) * i;
                            const y1 = aimStartY + (dy / dist) * i;
                            const x2 = aimStartX + (dx / dist) * (i + 8);
                            const y2 = aimStartY + (dy / dist) * (i + 8);
                            aimIndicator.lineBetween(x1, y1, x2, y2);
                        }
                        
                        // Cercle cible
                        aimIndicator.lineStyle(2, 0xff3333, 1);
                        aimIndicator.strokeCircle(mouseX, mouseY, 10);
                    }
                }
            }

            // Update projectiles MANUELLEMENT
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                
                // Bouger le projectile
                proj.x += proj.vx * (delta / 1000);
                proj.y += proj.vy * (delta / 1000);
                
                // Collision avec boss
                const dist = Phaser.Math.Distance.Between(proj.x, proj.y, boss.x, boss.y);
                if (dist < 60) {
                    hitBoss(this, 18);
                    if (proj.glow && proj.glow.scene) proj.glow.destroy();
                    proj.destroy();
                    projectiles.splice(i, 1);
                    continue;
                }
                
                // Hors √©cran
                if (proj.x < -50 || proj.x > 1050 || proj.y < -50 || proj.y > 750) {
                    if (proj.glow && proj.glow.scene) proj.glow.destroy();
                    proj.destroy();
                    projectiles.splice(i, 1);
                }
            }

            // Update boss projectiles
            for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                const bProj = bossProjectiles[i];
                
                bProj.x += bProj.vx * (delta / 1000);
                bProj.y += bProj.vy * (delta / 1000);
                
                // Collision avec joueur
                const distToPlayer = Phaser.Math.Distance.Between(bProj.x, bProj.y, player.x, player.y);
                if (distToPlayer < 25) {
                    hitPlayer(this, 10);
                    bProj.destroy();
                    bossProjectiles.splice(i, 1);
                    continue;
                }
                
                // Hors √©cran
                if (bProj.x < -50 || bProj.x > 1050 || bProj.y < -50 || bProj.y > 750) {
                    bProj.destroy();
                    bossProjectiles.splice(i, 1);
                }
            }

            // Regen stamina
            if (playerStamina < 100) {
                playerStamina = Math.min(100, playerStamina + 0.4);
                updateStaminaBar();
            }

            // Boss AI simple
            if (time > bossNextAttackTime) {
                bossNextAttackTime = time + Phaser.Math.Between(3000, 5000);
                bossAttack(this);
            }

            updateHealthBars();
        }

        function shootProjectile(scene, angle) {
            canAttack = false;
            playerStamina -= 20;
            
            const speed = 650;
            const startX = player.x + Math.cos(angle) * 30;
            const startY = player.y + Math.sin(angle) * 30;
            
            // Muzzle flash
            const flash = scene.add.circle(startX, startY, 20, 0xffffff, 0.9);
            scene.tweens.add({
                targets: flash,
                scale: 2,
                alpha: 0,
                duration: 150,
                onComplete: () => flash.destroy()
            });
            
            // Projectile avec glow
            const proj = scene.add.circle(startX, startY, 10, 0x66ffff);
            proj.setDepth(150);
            proj.vx = Math.cos(angle) * speed;
            proj.vy = Math.sin(angle) * speed;
            
            // Glow autour du projectile
            const projGlow = scene.add.circle(startX, startY, 18, 0x66ffff, 0.6);
            projGlow.setDepth(149);
            proj.glow = projGlow;
            
            projectiles.push(proj);
            
            // Trail am√©lior√©
            scene.time.addEvent({
                delay: 30,
                repeat: 60,
                callback: () => {
                    if (!proj.scene) return;
                    
                    // Update glow position
                    if (proj.glow && proj.glow.scene) {
                        proj.glow.x = proj.x;
                        proj.glow.y = proj.y;
                    }
                    
                    // Trail particles
                    const trail = scene.add.circle(proj.x, proj.y, 7, 0x66ffff, 0.7);
                    trail.setDepth(148);
                    scene.tweens.add({
                        targets: trail,
                        alpha: 0,
                        scale: 0.2,
                        duration: 400,
                        ease: 'Power2',
                        onComplete: () => trail.destroy()
                    });
                }
            });
            
            scene.time.delayedCall(400, () => canAttack = true);
        }

        function bossAttack(scene) {
            if (currentBossId === 1) boss1Attack(scene);
            else if (currentBossId === 2) boss2Attack(scene);
            else if (currentBossId === 3) boss3Attack(scene);
        }

        function boss1Attack(scene) {
            // Sentinel: Slash horizontal
            const warning = scene.add.rectangle(boss.x - 100, boss.y, 150, 130, 0xff0051, 0.2);
            warning.setStrokeStyle(3, 0xff0051);
            
            scene.tweens.add({
                targets: warning,
                alpha: 0.5,
                duration: 800,
                yoyo: true,
                onComplete: () => {
                    warning.destroy();
                    
                    const slashZone = scene.add.rectangle(boss.x - 100, boss.y, 150, 130, 0xff6666, 0.7);
                    scene.physics.add.existing(slashZone);
                    
                    const dist = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
                    if (dist < 120 && !isDodging) {
                        hitPlayer(scene, 15);
                    }
                    
                    scene.tweens.add({
                        targets: slashZone,
                        alpha: 0,
                        duration: 200,
                        onComplete: () => slashZone.destroy()
                    });
                }
            });
        }

        function boss2Attack(scene) {
            // Gunner: 5 projectiles en √©ventail
            const warning = scene.add.circle(boss.x, boss.y, 35, 0xff6600, 0.3);
            warning.setStrokeStyle(4, 0xff6600);
            
            scene.tweens.add({
                targets: warning,
                radius: 55,
                alpha: 0,
                duration: 700,
                onComplete: () => {
                    warning.destroy();
                    
                    // Tirer 5 projectiles vers le joueur
                    const angleToPlayer = Math.atan2(player.y - boss.y, player.x - boss.x);
                    const spread = Math.PI / 4;
                    
                    for (let i = -2; i <= 2; i++) {
                        const angle = angleToPlayer + (i * spread / 4);
                        const bossProj = scene.add.circle(boss.x, boss.y, 8, 0xff6600);
                        bossProj.setDepth(150);
                        bossProj.vx = Math.cos(angle) * 300;
                        bossProj.vy = Math.sin(angle) * 300;
                        bossProj.isBossProj = true;
                        
                        bossProjectiles.push(bossProj);
                        
                        // Auto destroy apr√®s 3s
                        scene.time.delayedCall(3000, () => {
                            if (bossProj.scene) {
                                const idx = bossProjectiles.indexOf(bossProj);
                                if (idx > -1) bossProjectiles.splice(idx, 1);
                                bossProj.destroy();
                            }
                        });
                    }
                }
            });
        }

        function boss3Attack(scene) {
            // Dasher: Dash rapide vers le joueur
            const targetX = player.x;
            const targetY = player.y;
            
            // Telegraph line
            const line = scene.add.line(0, 0, boss.x, boss.y, targetX, targetY, 0xcc00ff, 0.6);
            line.setLineWidth(5);
            
            scene.tweens.add({
                targets: line,
                alpha: 0,
                duration: 500,
                onComplete: () => {
                    line.destroy();
                    
                    // DASH rapide
                    scene.tweens.add({
                        targets: boss,
                        x: targetX,
                        y: targetY,
                        duration: 200,
                        ease: 'Power2',
                        onComplete: () => {
                            const dist = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
                            if (dist < 70) hitPlayer(scene, 20);
                            
                            // Screen shake
                            scene.cameras.main.shake(150, 0.007);
                        }
                    });
                }
            });
        }

        function bossAttackOLD(scene) {
            // Slash simple
            const warning = scene.add.rectangle(boss.x - 100, boss.y, 150, 130, 0xff0051, 0.2);
            warning.setStrokeStyle(3, 0xff0051);
            
            scene.tweens.add({
                targets: warning,
                alpha: 0.5,
                duration: 800,
                yoyo: true,
                onComplete: () => {
                    warning.destroy();
                    
                    const slashZone = scene.add.rectangle(boss.x - 100, boss.y, 150, 130, 0xff6666, 0.7);
                    scene.physics.add.existing(slashZone);
                    
                    const dist = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
                    if (dist < 120 && !isDodging) {
                        hitPlayer(scene, 15);
                    }
                    
                    scene.tweens.add({
                        targets: slashZone,
                        alpha: 0,
                        duration: 200,
                        onComplete: () => slashZone.destroy()
                    });
                }
            });
        }

        function hitBoss(scene, damage) {
            bossHealth = Math.max(0, bossHealth - damage);
            
            // HIT FREEZE (pause courte pour l'impact)
            scene.physics.pause();
            scene.time.delayedCall(40, () => scene.physics.resume());
            
            // Flash blanc
            const flash = scene.add.rectangle(boss.x, boss.y, 100, 140, 0xffffff, 0.8);
            flash.setDepth(200);
            scene.tweens.add({
                targets: flash,
                alpha: 0,
                duration: 100,
                onComplete: () => flash.destroy()
            });
            
            // Boss flash
            scene.tweens.add({ targets: boss, alpha: 0.3, duration: 60, yoyo: true });
            
            // EXPLOSION de particles
            const bossData = BOSSES[currentBossId];
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                const dist = Phaser.Math.Between(40, 80);
                const size = Phaser.Math.Between(4, 10);
                const p = scene.add.circle(boss.x, boss.y, size, bossData.color);
                p.setDepth(199);
                
                scene.tweens.add({
                    targets: p,
                    x: boss.x + Math.cos(angle) * dist,
                    y: boss.y + Math.sin(angle) * dist,
                    alpha: 0,
                    scale: 0.3,
                    duration: 600,
                    ease: 'Power2',
                    onComplete: () => p.destroy()
                });
            }
            
            // Ring explosion
            const ring = scene.add.circle(boss.x, boss.y, 30, bossData.color, 0);
            ring.setStrokeStyle(4, bossData.color, 0.8);
            ring.setDepth(198);
            scene.tweens.add({
                targets: ring,
                radius: 100,
                alpha: 0,
                duration: 400,
                ease: 'Power2',
                onComplete: () => ring.destroy()
            });
            
            // SCREEN SHAKE intense
            scene.cameras.main.shake(120, 0.008);
            
            // Slow-mo si mort du boss
            if (bossHealth <= 0) {
                scene.time.timeScale = 0.3;
                scene.time.delayedCall(400, () => {
                    scene.time.timeScale = 1;
                });
            }
        }

        function hitPlayer(scene, damage) {
            playerHealth = Math.max(0, playerHealth - damage);
            
            // Flash rouge
            const flash = scene.add.rectangle(player.x, player.y, 60, 60, 0xff0000, 0.6);
            flash.setDepth(200);
            scene.tweens.add({
                targets: flash,
                alpha: 0,
                duration: 150,
                onComplete: () => flash.destroy()
            });
            
            scene.tweens.add({ targets: player, alpha: 0.2, duration: 80, yoyo: true });
            
            // Particles de d√©g√¢ts
            for (let i = 0; i < 8; i++) {
                const angle = Phaser.Math.Between(0, 360) * Math.PI / 180;
                const p = scene.add.circle(player.x, player.y, 5, 0xff3355);
                scene.tweens.add({
                    targets: p,
                    x: player.x + Math.cos(angle) * 40,
                    y: player.y + Math.sin(angle) * 40,
                    alpha: 0,
                    duration: 400,
                    onComplete: () => p.destroy()
                });
            }
            
            // Screen shake
            scene.cameras.main.shake(150, 0.01);
        }

        function updateHealthBars() {
            playerHealthText.width = 350 * (playerHealth / 100);
            bossHealthText.width = 330 * (bossHealth / 500);
            
            if (playerHealth < 30) playerHealthText.fillColor = 0xff0000;
            else if (playerHealth < 60) playerHealthText.fillColor = 0xffaa00;
            else playerHealthText.fillColor = 0x00ff88;
        }

        function updateStaminaBar() {
            staminaText.width = 250 * (playerStamina / 100);
        }

        function handleGameOver(scene) {
            scene.physics.pause();
            const isVictory = bossHealth <= 0;
            const msg = isVictory ? '‚ú® VICTOIRE ‚ú®' : 'üíÄ D√âFAITE üíÄ';
            const color = isVictory ? '#00ff88' : '#ff3355';
            
            // Unlock next boss si victoire
            if (isVictory && currentBossId === unlockedBosses && currentBossId < 3) {
                unlockedBosses++;
                localStorage.setItem('unlockedBosses', unlockedBosses);
            }
            
            const txt = scene.add.text(500, 250, msg, { 
                fontSize: '64px', 
                fill: color, 
                fontStyle: 'bold', 
                stroke: '#000', 
                strokeThickness: 6 
            }).setOrigin(0.5);
            
            scene.tweens.add({ targets: txt, scale: 1.15, duration: 600, yoyo: true, repeat: -1 });
            
            // Boss name
            scene.add.text(500, 340, BOSSES[currentBossId].name + ' VAINCU!', {
                fontSize: '20px',
                fill: '#888'
            }).setOrigin(0.5).setVisible(isVictory);
            
            // Boutons
            const retryBtn = scene.add.text(400, 450, '[RETRY]', { 
                fontSize: '24px', 
                fill: '#00d4ff', 
                backgroundColor: '#00000099', 
                padding: { x: 20, y: 10 }
            }).setOrigin(0.5).setInteractive({ useHandCursor: true });
            
            retryBtn.on('pointerdown', () => {
                scene.scene.restart();
                playerHealth = 100;
                bossHealth = BOSSES[currentBossId].hp;
                playerStamina = 100;
                projectiles = [];
                bossProjectiles = [];
            });
            
            // Boss select button
            const selectBtn = scene.add.text(600, 450, '[SELECT BOSS]', { 
                fontSize: '24px', 
                fill: '#ff6600', 
                backgroundColor: '#00000099', 
                padding: { x: 20, y: 10 }
            }).setOrigin(0.5).setInteractive({ useHandCursor: true });
            
            selectBtn.on('pointerdown', () => showBossSelect(scene));
            
            // Next boss button (si unlocked)
            if (isVictory && currentBossId < unlockedBosses) {
                const nextBtn = scene.add.text(500, 520, '‚Üí NEXT BOSS', { 
                    fontSize: '20px', 
                    fill: '#00ff88', 
                    backgroundColor: '#00000099', 
                    padding: { x: 15, y: 8 }
                }).setOrigin(0.5).setInteractive({ useHandCursor: true });
                
                nextBtn.on('pointerdown', () => {
                    currentBossId++;
                    localStorage.setItem('currentBoss', currentBossId);
                    scene.scene.restart();
                    playerHealth = 100;
                    bossHealth = BOSSES[currentBossId].hp;
                    playerStamina = 100;
                    projectiles = [];
                    bossProjectiles = [];
                });
            }
        }

        function showBossSelect(scene) {
            // Clear screen
            scene.children.removeAll();
            
            scene.add.text(500, 80, 'SELECT BOSS', {
                fontSize: '48px',
                fill: '#00d4ff',
                fontStyle: 'bold'
            }).setOrigin(0.5);
            
            // Boss cards
            const startX = 250;
            const spacing = 250;
            
            [1, 2, 3].forEach((bossId, index) => {
                const bossData = BOSSES[bossId];
                const x = startX + (index * spacing);
                const y = 350;
                const unlocked = bossId <= unlockedBosses;
                
                // Card
                const card = scene.add.rectangle(x, y, 200, 250, 0x1a1a2e, unlocked ? 0.8 : 0.3);
                card.setStrokeStyle(3, bossData.color, unlocked ? 1 : 0.3);
                
                if (unlocked) {
                    card.setInteractive({ useHandCursor: true });
                    
                    card.on('pointerover', () => {
                        scene.tweens.add({ targets: card, scaleX: 1.05, scaleY: 1.05, duration: 200 });
                    });
                    
                    card.on('pointerout', () => {
                        scene.tweens.add({ targets: card, scaleX: 1, scaleY: 1, duration: 200 });
                    });
                    
                    card.on('pointerdown', () => {
                        currentBossId = bossId;
                        localStorage.setItem('currentBoss', currentBossId);
                        scene.scene.restart();
                        playerHealth = 100;
                        bossHealth = BOSSES[currentBossId].hp;
                        playerStamina = 100;
                        projectiles = [];
                        bossProjectiles = [];
                    });
                }
                
                // Boss preview
                const preview = scene.add.circle(x, y - 60, 35, bossData.color, unlocked ? 1 : 0.3);
                const glow = scene.add.circle(x, y - 60, 50, bossData.color, unlocked ? 0.3 : 0.1);
                
                // Name
                scene.add.text(x, y + 30, bossData.name, {
                    fontSize: '18px',
                    fill: unlocked ? '#fff' : '#444',
                    fontStyle: 'bold'
                }).setOrigin(0.5);
                
                // HP
                scene.add.text(x, y + 60, 'HP: ' + bossData.hp, {
                    fontSize: '14px',
                    fill: unlocked ? '#ffaa00' : '#333'
                }).setOrigin(0.5);
                
                // Lock
                if (!unlocked) {
                    scene.add.text(x, y, 'üîí', { fontSize: '32px' }).setOrigin(0.5);
                }
            });
        }

        window.addEventListener('load', () => { game = new Phaser.Game(config); });
    </script>
</body>
</html>
