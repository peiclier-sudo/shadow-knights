<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shadow Knights - SIMPLE VERSION</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        * { margin: 0; padding: 0; overflow: hidden; }
        body {
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #game-container { box-shadow: 0 0 50px rgba(0,212,255,0.5); }
        @media (max-width: 900px) and (orientation: portrait) {
            body::before {
                content: "ðŸ“± Tournez en paysage";
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: #fff;
                font-size: 24px;
                z-index: 9999;
            }
            #game-container { display: none; }
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
        const config = {
            type: Phaser.AUTO,
            width: 1000,
            height: 700,
            parent: 'game-container',
            backgroundColor: '#0f0f1e',
            physics: { default: 'arcade', arcade: { gravity: { y: 0 }}},
            scene: { create, update },
            scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH }
        };

        // BOSS DATA
        const BOSSES = {
            1: { name: 'SENTINEL', hp: 400, color: 0xff0051 },
            2: { name: 'GUNNER', hp: 500, color: 0xff6600 },
            3: { name: 'DASHER', hp: 600, color: 0xcc00ff }
        };
        
        let currentBossId = parseInt(localStorage.getItem('currentBoss')) || 1;
        let unlockedBosses = parseInt(localStorage.getItem('unlockedBosses')) || 1;

        let game, player, boss;
        let playerHealth = 100, bossHealth = BOSSES[currentBossId].hp, playerStamina = 100;
        let isDodging = false, canDodge = true, canAttack = true;
        let playerHealthBar, bossHealthBar, staminaBar, playerHealthText, bossHealthText, staminaText;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let bossNextAttackTime = 0;
        
        // Mobile controls
        let moveJoy = { active: false, deltaX: 0, deltaY: 0 };
        let aimJoy = { active: false, angle: 0 };
        let projectiles = [];
        let bossProjectiles = [];
        
        // Desktop controls
        let leftMouseDown = false;
        let rightMouseDown = false;
        let mouseX = 0, mouseY = 0;
        let aimStartX = 0, aimStartY = 0;
        let aimIndicator = null;

        function create() {
            // Grille
            const g = this.add.graphics();
            g.lineStyle(1, 0x1a1a2e, 0.3);
            for (let i = 0; i < 1000; i += 50) g.lineBetween(i, 0, i, 700);
            for (let i = 0; i < 700; i += 50) g.lineBetween(0, i, 1000, i);

            // Joueur
            player = this.add.circle(150, 350, 22, 0x00d4ff);
            this.physics.add.existing(player);
            player.body.setCollideWorldBounds(true);
            player.glow = this.add.circle(150, 350, 35, 0x00d4ff, 0.3);

            // Boss - DiffÃ©rent selon ID
            const bossData = BOSSES[currentBossId];
            boss = this.add.container(850, 350);
            
            if (currentBossId === 1) {
                // Sentinel: Rectangle + circle
                boss.add([
                    this.add.rectangle(0, 0, 70, 100, bossData.color),
                    this.add.circle(0, -60, 30, bossData.color)
                ]);
            } else if (currentBossId === 2) {
                // Gunner: Star/Hexagon
                boss.add([
                    this.add.star(0, 0, 6, 20, 40, bossData.color),
                    this.add.circle(0, 0, 12, 0xffffff)
                ]);
            } else if (currentBossId === 3) {
                // Dasher: Triangle
                const tri = this.add.triangle(0, 0, 0, -40, -35, 35, 35, 35, bossData.color);
                boss.add(tri);
            }
            
            this.physics.add.existing(boss);
            boss.body.setSize(70, 130);
            boss.body.setCollideWorldBounds(true);
            boss.body.immovable = true;

            // UI
            this.add.text(500, 30, bossData.name, { fontSize: '28px', fill: '#' + bossData.color.toString(16).padStart(6, '0'), fontStyle: 'bold' }).setOrigin(0.5);
            
            this.add.text(20, 20, 'VOUS', { fontSize: '18px', fill: '#00d4ff', fontStyle: 'bold' });
            playerHealthBar = this.add.rectangle(20, 55, 350, 25, 0x1a1a2e).setOrigin(0, 0.5).setStrokeStyle(3, 0x333355);
            playerHealthText = this.add.rectangle(20, 55, 350, 25, 0x00ff88).setOrigin(0, 0.5);
            
            this.add.text(20, 82, 'STAMINA', { fontSize: '14px', fill: '#ffaa00' });
            staminaBar = this.add.rectangle(20, 105, 250, 16, 0x1a1a2e).setOrigin(0, 0.5).setStrokeStyle(2, 0x333355);
            staminaText = this.add.rectangle(20, 105, 250, 16, 0xffaa00).setOrigin(0, 0.5);

            this.add.text(650, 70, 'BOSS', { fontSize: '14px', fill: '#' + bossData.color.toString(16).padStart(6, '0') });
            bossHealthBar = this.add.rectangle(650, 95, 330, 28, 0x1a1a2e).setOrigin(0, 0.5).setStrokeStyle(3, 0x333355);
            bossHealthText = this.add.rectangle(650, 95, 330, 28, bossData.color).setOrigin(0, 0.5);

            if (isMobile) createMobileControls(this);
            else createDesktopControls(this);

            const instructions = isMobile ? 'Gauche: Bouger | Droite: Tirer' 
                : 'Clic Gauche: Aller vers souris | Clic Droit: Viser & Tirer';
            this.add.text(500, 680, instructions, { fontSize: '13px', fill: '#aaa', backgroundColor: '#00000099', padding: { x: 15, y: 8 }}).setOrigin(0.5);
        }

        function createDesktopControls(scene) {
            // Indicateur de visÃ©e
            aimIndicator = scene.add.graphics();
            aimIndicator.setDepth(500);
            
            // DÃ©sactiver menu contextuel
            scene.input.mouse.disableContextMenu();
            
            // CLIC GAUCHE = MOUVEMENT vers la souris
            scene.input.on('pointerdown', (pointer) => {
                if (pointer.leftButtonDown()) {
                    leftMouseDown = true;
                    mouseX = pointer.x;
                    mouseY = pointer.y;
                }
                
                if (pointer.rightButtonDown()) {
                    rightMouseDown = true;
                    aimStartX = player.x;
                    aimStartY = player.y;
                    mouseX = pointer.x;
                    mouseY = pointer.y;
                }
            });
            
            scene.input.on('pointermove', (pointer) => {
                mouseX = pointer.x;
                mouseY = pointer.y;
            });
            
            scene.input.on('pointerup', (pointer) => {
                if (pointer.button === 0) { // Left button
                    leftMouseDown = false;
                }
                
                if (pointer.button === 2) { // Right button
                    if (rightMouseDown && canAttack && playerStamina >= 20) {
                        const angle = Math.atan2(mouseY - aimStartY, mouseX - aimStartX);
                        shootProjectile(scene, angle);
                    }
                    rightMouseDown = false;
                }
            });
        }

        function createMobileControls(scene) {
            // Zones
            const leftZone = scene.add.rectangle(250, 350, 500, 700, 0x0066ff, 0.1);
            const rightZone = scene.add.rectangle(750, 350, 500, 700, 0xff6666, 0.1);
            scene.add.text(250, 50, 'â¬…ï¸ BOUGER', { fontSize: '18px', fill: '#00d4ff', fontStyle: 'bold' }).setOrigin(0.5);
            scene.add.text(750, 50, 'TIRER âž¡ï¸', { fontSize: '18px', fill: '#ff6666', fontStyle: 'bold' }).setOrigin(0.5);
            
            let leftTouch = null, rightTouch = null;
            
            scene.input.addPointer(3);
            
            scene.input.on('pointerdown', (pointer) => {
                if (pointer.x < 500 && !leftTouch) {
                    leftTouch = {
                        id: pointer.id,
                        startX: pointer.x,
                        startY: pointer.y,
                        base: scene.add.circle(pointer.x, pointer.y, 55, 0x0033aa, 0.7).setDepth(300),
                        thumb: scene.add.circle(pointer.x, pointer.y, 28, 0x00d4ff, 1).setDepth(301)
                    };
                }
                
                if (pointer.x >= 500 && !rightTouch) {
                    rightTouch = {
                        id: pointer.id,
                        startX: pointer.x,
                        startY: pointer.y,
                        base: scene.add.circle(pointer.x, pointer.y, 55, 0xaa3300, 0.7).setDepth(300),
                        thumb: scene.add.circle(pointer.x, pointer.y, 28, 0xff6666, 1).setDepth(301)
                    };
                }
            });
            
            scene.input.on('pointermove', (pointer) => {
                if (!pointer.isDown) return;
                
                if (leftTouch && pointer.id === leftTouch.id) {
                    const dx = pointer.x - leftTouch.startX;
                    const dy = pointer.y - leftTouch.startY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const max = 55;
                    
                    if (dist < max) {
                        leftTouch.thumb.x = leftTouch.startX + dx;
                        leftTouch.thumb.y = leftTouch.startY + dy;
                        moveJoy.deltaX = dx / max;
                        moveJoy.deltaY = dy / max;
                    } else {
                        const angle = Math.atan2(dy, dx);
                        leftTouch.thumb.x = leftTouch.startX + Math.cos(angle) * max;
                        leftTouch.thumb.y = leftTouch.startY + Math.sin(angle) * max;
                        moveJoy.deltaX = Math.cos(angle);
                        moveJoy.deltaY = Math.sin(angle);
                    }
                    moveJoy.active = true;
                }
                
                if (rightTouch && pointer.id === rightTouch.id) {
                    const dx = pointer.x - rightTouch.startX;
                    const dy = pointer.y - rightTouch.startY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const max = 55;
                    
                    if (dist < max) {
                        rightTouch.thumb.x = rightTouch.startX + dx;
                        rightTouch.thumb.y = rightTouch.startY + dy;
                    } else {
                        const angle = Math.atan2(dy, dx);
                        rightTouch.thumb.x = rightTouch.startX + Math.cos(angle) * max;
                        rightTouch.thumb.y = rightTouch.startY + Math.sin(angle) * max;
                    }
                    
                    aimJoy.angle = Math.atan2(dy, dx);
                    aimJoy.active = dist > 15;
                }
            });
            
            scene.input.on('pointerup', (pointer) => {
                if (leftTouch && pointer.id === leftTouch.id) {
                    leftTouch.base.destroy();
                    leftTouch.thumb.destroy();
                    leftTouch = null;
                    moveJoy.active = false;
                    moveJoy.deltaX = 0;
                    moveJoy.deltaY = 0;
                }
                
                if (rightTouch && pointer.id === rightTouch.id) {
                    if (aimJoy.active && canAttack && playerStamina >= 20) {
                        shootProjectile(scene, aimJoy.angle);
                    }
                    rightTouch.base.destroy();
                    rightTouch.thumb.destroy();
                    rightTouch = null;
                    aimJoy.active = false;
                }
            });
        }

        function update(time, delta) {
            if (playerHealth <= 0 || bossHealth <= 0) {
                handleGameOver(this);
                return;
            }

            // Mouvement
            const speed = 220;
            let vx = 0, vy = 0;
            
            // MOBILE: Joystick
            if (isMobile && moveJoy.active) {
                vx = moveJoy.deltaX * speed;
                vy = moveJoy.deltaY * speed;
            }
            
            // DESKTOP: Point-and-click avec clic gauche
            if (!isMobile && leftMouseDown) {
                const dx = mouseX - player.x;
                const dy = mouseY - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 10) { // Deadzone
                    const angle = Math.atan2(dy, dx);
                    vx = Math.cos(angle) * speed;
                    vy = Math.sin(angle) * speed;
                    
                    // Ralentir quand proche de la cible
                    if (dist < 50) {
                        vx *= (dist / 50);
                        vy *= (dist / 50);
                    }
                }
            }
            
            player.body.setVelocity(vx, vy);
            player.glow.x = player.x;
            player.glow.y = player.y;
            
            // Indicateur de visÃ©e (desktop clic droit)
            if (!isMobile && aimIndicator) {
                aimIndicator.clear();
                
                if (rightMouseDown) {
                    const dx = mouseX - aimStartX;
                    const dy = mouseY - aimStartY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 15) {
                        // Ligne de visÃ©e
                        aimIndicator.lineStyle(3, 0xff6666, 0.8);
                        for (let i = 0; i < dist; i += 15) {
                            const x1 = aimStartX + (dx / dist) * i;
                            const y1 = aimStartY + (dy / dist) * i;
                            const x2 = aimStartX + (dx / dist) * (i + 8);
                            const y2 = aimStartY + (dy / dist) * (i + 8);
                            aimIndicator.lineBetween(x1, y1, x2, y2);
                        }
                        
                        // Cercle cible
                        aimIndicator.lineStyle(2, 0xff3333, 1);
                        aimIndicator.strokeCircle(mouseX, mouseY, 10);
                    }
                }
            }

            // Update projectiles MANUELLEMENT
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                
                // Bouger le projectile
                proj.x += proj.vx * (delta / 1000);
                proj.y += proj.vy * (delta / 1000);
                
                // Collision avec boss
                const dist = Phaser.Math.Distance.Between(proj.x, proj.y, boss.x, boss.y);
                if (dist < 60) {
                    hitBoss(this, 18);
                    proj.destroy();
                    projectiles.splice(i, 1);
                    continue;
                }
                
                // Hors Ã©cran
                if (proj.x < -50 || proj.x > 1050 || proj.y < -50 || proj.y > 750) {
                    proj.destroy();
                    projectiles.splice(i, 1);
                }
            }

            // Update boss projectiles
            for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                const bProj = bossProjectiles[i];
                
                bProj.x += bProj.vx * (delta / 1000);
                bProj.y += bProj.vy * (delta / 1000);
                
                // Collision avec joueur
                const distToPlayer = Phaser.Math.Distance.Between(bProj.x, bProj.y, player.x, player.y);
                if (distToPlayer < 25) {
                    hitPlayer(this, 10);
                    bProj.destroy();
                    bossProjectiles.splice(i, 1);
                    continue;
                }
                
                // Hors Ã©cran
                if (bProj.x < -50 || bProj.x > 1050 || bProj.y < -50 || bProj.y > 750) {
                    bProj.destroy();
                    bossProjectiles.splice(i, 1);
                }
            }

            // Regen stamina
            if (playerStamina < 100) {
                playerStamina = Math.min(100, playerStamina + 0.4);
                updateStaminaBar();
            }

            // Boss AI simple
            if (time > bossNextAttackTime) {
                bossNextAttackTime = time + Phaser.Math.Between(3000, 5000);
                bossAttack(this);
            }

            updateHealthBars();
        }

        function shootProjectile(scene, angle) {
            canAttack = false;
            playerStamina -= 20;
            
            const speed = 600;
            const proj = scene.add.circle(
                player.x + Math.cos(angle) * 30,
                player.y + Math.sin(angle) * 30,
                10,
                0x66ffff
            );
            proj.setDepth(150);
            
            // Stocker la vÃ©locitÃ©
            proj.vx = Math.cos(angle) * speed;
            proj.vy = Math.sin(angle) * speed;
            
            projectiles.push(proj);
            
            console.log('ðŸ”« SHOT:', proj.vx.toFixed(0), proj.vy.toFixed(0));
            
            // Trail
            scene.time.addEvent({
                delay: 50,
                repeat: 40,
                callback: () => {
                    if (!proj.scene) return;
                    const trail = scene.add.circle(proj.x, proj.y, 6, 0x66ffff, 0.5);
                    scene.tweens.add({
                        targets: trail,
                        alpha: 0,
                        scale: 0.3,
                        duration: 400,
                        onComplete: () => trail.destroy()
                    });
                }
            });
            
            scene.time.delayedCall(500, () => canAttack = true);
        }

        function bossAttack(scene) {
            if (currentBossId === 1) boss1Attack(scene);
            else if (currentBossId === 2) boss2Attack(scene);
            else if (currentBossId === 3) boss3Attack(scene);
        }

        function boss1Attack(scene) {
            // Sentinel: Slash horizontal
            const warning = scene.add.rectangle(boss.x - 100, boss.y, 150, 130, 0xff0051, 0.2);
            warning.setStrokeStyle(3, 0xff0051);
            
            scene.tweens.add({
                targets: warning,
                alpha: 0.5,
                duration: 800,
                yoyo: true,
                onComplete: () => {
                    warning.destroy();
                    
                    const slashZone = scene.add.rectangle(boss.x - 100, boss.y, 150, 130, 0xff6666, 0.7);
                    scene.physics.add.existing(slashZone);
                    
                    const dist = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
                    if (dist < 120 && !isDodging) {
                        hitPlayer(scene, 15);
                    }
                    
                    scene.tweens.add({
                        targets: slashZone,
                        alpha: 0,
                        duration: 200,
                        onComplete: () => slashZone.destroy()
                    });
                }
            });
        }

        function boss2Attack(scene) {
            // Gunner: 5 projectiles en Ã©ventail
            const warning = scene.add.circle(boss.x, boss.y, 35, 0xff6600, 0.3);
            warning.setStrokeStyle(4, 0xff6600);
            
            scene.tweens.add({
                targets: warning,
                radius: 55,
                alpha: 0,
                duration: 700,
                onComplete: () => {
                    warning.destroy();
                    
                    // Tirer 5 projectiles vers le joueur
                    const angleToPlayer = Math.atan2(player.y - boss.y, player.x - boss.x);
                    const spread = Math.PI / 4;
                    
                    for (let i = -2; i <= 2; i++) {
                        const angle = angleToPlayer + (i * spread / 4);
                        const bossProj = scene.add.circle(boss.x, boss.y, 8, 0xff6600);
                        bossProj.setDepth(150);
                        bossProj.vx = Math.cos(angle) * 300;
                        bossProj.vy = Math.sin(angle) * 300;
                        bossProj.isBossProj = true;
                        
                        bossProjectiles.push(bossProj);
                        
                        // Auto destroy aprÃ¨s 3s
                        scene.time.delayedCall(3000, () => {
                            if (bossProj.scene) {
                                const idx = bossProjectiles.indexOf(bossProj);
                                if (idx > -1) bossProjectiles.splice(idx, 1);
                                bossProj.destroy();
                            }
                        });
                    }
                }
            });
        }

        function boss3Attack(scene) {
            // Dasher: Dash rapide vers le joueur
            const targetX = player.x;
            const targetY = player.y;
            
            // Telegraph line
            const line = scene.add.line(0, 0, boss.x, boss.y, targetX, targetY, 0xcc00ff, 0.6);
            line.setLineWidth(5);
            
            scene.tweens.add({
                targets: line,
                alpha: 0,
                duration: 500,
                onComplete: () => {
                    line.destroy();
                    
                    // DASH rapide
                    scene.tweens.add({
                        targets: boss,
                        x: targetX,
                        y: targetY,
                        duration: 200,
                        ease: 'Power2',
                        onComplete: () => {
                            const dist = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
                            if (dist < 70) hitPlayer(scene, 20);
                            
                            // Screen shake
                            scene.cameras.main.shake(150, 0.007);
                        }
                    });
                }
            });
        }

        function bossAttackOLD(scene) {
            // Slash simple
            const warning = scene.add.rectangle(boss.x - 100, boss.y, 150, 130, 0xff0051, 0.2);
            warning.setStrokeStyle(3, 0xff0051);
            
            scene.tweens.add({
                targets: warning,
                alpha: 0.5,
                duration: 800,
                yoyo: true,
                onComplete: () => {
                    warning.destroy();
                    
                    const slashZone = scene.add.rectangle(boss.x - 100, boss.y, 150, 130, 0xff6666, 0.7);
                    scene.physics.add.existing(slashZone);
                    
                    const dist = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
                    if (dist < 120 && !isDodging) {
                        hitPlayer(scene, 15);
                    }
                    
                    scene.tweens.add({
                        targets: slashZone,
                        alpha: 0,
                        duration: 200,
                        onComplete: () => slashZone.destroy()
                    });
                }
            });
        }

        function hitBoss(scene, damage) {
            bossHealth = Math.max(0, bossHealth - damage);
            scene.tweens.add({ targets: boss, alpha: 0.5, duration: 80, yoyo: true });
            
            // Particles
            for (let i = 0; i < 10; i++) {
                const p = scene.add.circle(boss.x, boss.y, 5, 0xff0051);
                const angle = (Math.PI * 2 * i) / 10;
                scene.tweens.add({
                    targets: p,
                    x: boss.x + Math.cos(angle) * 50,
                    y: boss.y + Math.sin(angle) * 50,
                    alpha: 0,
                    duration: 500,
                    onComplete: () => p.destroy()
                });
            }
        }

        function hitPlayer(scene, damage) {
            playerHealth = Math.max(0, playerHealth - damage);
            scene.tweens.add({ targets: player, alpha: 0.3, duration: 100, yoyo: true });
        }

        function updateHealthBars() {
            playerHealthText.width = 350 * (playerHealth / 100);
            bossHealthText.width = 330 * (bossHealth / 500);
            
            if (playerHealth < 30) playerHealthText.fillColor = 0xff0000;
            else if (playerHealth < 60) playerHealthText.fillColor = 0xffaa00;
            else playerHealthText.fillColor = 0x00ff88;
        }

        function updateStaminaBar() {
            staminaText.width = 250 * (playerStamina / 100);
        }

        function handleGameOver(scene) {
            scene.physics.pause();
            const isVictory = bossHealth <= 0;
            const msg = isVictory ? 'âœ¨ VICTOIRE âœ¨' : 'ðŸ’€ DÃ‰FAITE ðŸ’€';
            const color = isVictory ? '#00ff88' : '#ff3355';
            
            // Unlock next boss si victoire
            if (isVictory && currentBossId === unlockedBosses && currentBossId < 3) {
                unlockedBosses++;
                localStorage.setItem('unlockedBosses', unlockedBosses);
            }
            
            const txt = scene.add.text(500, 250, msg, { 
                fontSize: '64px', 
                fill: color, 
                fontStyle: 'bold', 
                stroke: '#000', 
                strokeThickness: 6 
            }).setOrigin(0.5);
            
            scene.tweens.add({ targets: txt, scale: 1.15, duration: 600, yoyo: true, repeat: -1 });
            
            // Boss name
            scene.add.text(500, 340, BOSSES[currentBossId].name + ' VAINCU!', {
                fontSize: '20px',
                fill: '#888'
            }).setOrigin(0.5).setVisible(isVictory);
            
            // Boutons
            const retryBtn = scene.add.text(400, 450, '[RETRY]', { 
                fontSize: '24px', 
                fill: '#00d4ff', 
                backgroundColor: '#00000099', 
                padding: { x: 20, y: 10 }
            }).setOrigin(0.5).setInteractive({ useHandCursor: true });
            
            retryBtn.on('pointerdown', () => {
                scene.scene.restart();
                playerHealth = 100;
                bossHealth = BOSSES[currentBossId].hp;
                playerStamina = 100;
                projectiles = [];
                bossProjectiles = [];
            });
            
            // Boss select button
            const selectBtn = scene.add.text(600, 450, '[SELECT BOSS]', { 
                fontSize: '24px', 
                fill: '#ff6600', 
                backgroundColor: '#00000099', 
                padding: { x: 20, y: 10 }
            }).setOrigin(0.5).setInteractive({ useHandCursor: true });
            
            selectBtn.on('pointerdown', () => showBossSelect(scene));
            
            // Next boss button (si unlocked)
            if (isVictory && currentBossId < unlockedBosses) {
                const nextBtn = scene.add.text(500, 520, 'â†’ NEXT BOSS', { 
                    fontSize: '20px', 
                    fill: '#00ff88', 
                    backgroundColor: '#00000099', 
                    padding: { x: 15, y: 8 }
                }).setOrigin(0.5).setInteractive({ useHandCursor: true });
                
                nextBtn.on('pointerdown', () => {
                    currentBossId++;
                    localStorage.setItem('currentBoss', currentBossId);
                    scene.scene.restart();
                    playerHealth = 100;
                    bossHealth = BOSSES[currentBossId].hp;
                    playerStamina = 100;
                    projectiles = [];
                    bossProjectiles = [];
                });
            }
        }

        function showBossSelect(scene) {
            // Clear screen
            scene.children.removeAll();
            
            scene.add.text(500, 80, 'SELECT BOSS', {
                fontSize: '48px',
                fill: '#00d4ff',
                fontStyle: 'bold'
            }).setOrigin(0.5);
            
            // Boss cards
            const startX = 250;
            const spacing = 250;
            
            [1, 2, 3].forEach((bossId, index) => {
                const bossData = BOSSES[bossId];
                const x = startX + (index * spacing);
                const y = 350;
                const unlocked = bossId <= unlockedBosses;
                
                // Card
                const card = scene.add.rectangle(x, y, 200, 250, 0x1a1a2e, unlocked ? 0.8 : 0.3);
                card.setStrokeStyle(3, bossData.color, unlocked ? 1 : 0.3);
                
                if (unlocked) {
                    card.setInteractive({ useHandCursor: true });
                    
                    card.on('pointerover', () => {
                        scene.tweens.add({ targets: card, scaleX: 1.05, scaleY: 1.05, duration: 200 });
                    });
                    
                    card.on('pointerout', () => {
                        scene.tweens.add({ targets: card, scaleX: 1, scaleY: 1, duration: 200 });
                    });
                    
                    card.on('pointerdown', () => {
                        currentBossId = bossId;
                        localStorage.setItem('currentBoss', currentBossId);
                        scene.scene.restart();
                        playerHealth = 100;
                        bossHealth = BOSSES[currentBossId].hp;
                        playerStamina = 100;
                        projectiles = [];
                        bossProjectiles = [];
                    });
                }
                
                // Boss preview
                const preview = scene.add.circle(x, y - 60, 35, bossData.color, unlocked ? 1 : 0.3);
                const glow = scene.add.circle(x, y - 60, 50, bossData.color, unlocked ? 0.3 : 0.1);
                
                // Name
                scene.add.text(x, y + 30, bossData.name, {
                    fontSize: '18px',
                    fill: unlocked ? '#fff' : '#444',
                    fontStyle: 'bold'
                }).setOrigin(0.5);
                
                // HP
                scene.add.text(x, y + 60, 'HP: ' + bossData.hp, {
                    fontSize: '14px',
                    fill: unlocked ? '#ffaa00' : '#333'
                }).setOrigin(0.5);
                
                // Lock
                if (!unlocked) {
                    scene.add.text(x, y, 'ðŸ”’', { fontSize: '32px' }).setOrigin(0.5);
                }
            });
        }

        window.addEventListener('load', () => { game = new Phaser.Game(config); });
    </script>
</body>
</html>
