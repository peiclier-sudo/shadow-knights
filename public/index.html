<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shadow Knights - PROFESSIONAL BALANCE</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            background: #000;
        }
        #game-container { 
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
        }
        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            object-fit: contain;
        }
        @media (max-width: 900px) and (orientation: portrait) {
            body::before {
                content: "ðŸ“± ROTATE";
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: #00d4ff;
                font-size: 32px;
                font-weight: bold;
                text-shadow: 0 0 20px #00d4ff;
                z-index: 9999;
            }
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
        // Configuration with dynamic sizing
        const config = {
            type: Phaser.WEBGL,
            parent: 'game-container',
            backgroundColor: '#0a0a14',
            physics: { default: 'arcade', arcade: { gravity: { y: 0 }}},
            scene: { create, update },
            scale: { 
                mode: Phaser.Scale.RESIZE,
                autoCenter: Phaser.Scale.CENTER_BOTH,
                width: '100%',
                height: '100%'
            },
            render: {
                antialias: true,
                powerPreference: 'high-performance'
            }
        };

        // BOSS DATA
        const BOSSES = {
            1: { name: 'SENTINEL', hp: 400, color: 0xff0051 },
            2: { name: 'GUNNER', hp: 500, color: 0xff6600 },
            3: { name: 'DASHER', hp: 600, color: 0xcc00ff }
        };
        
        let currentBossId = parseInt(localStorage.getItem('currentBoss')) || 1;
        let unlockedBosses = parseInt(localStorage.getItem('unlockedBosses')) || 1;

        let game, player, boss;
        let playerHealth = 100, bossHealth = BOSSES[currentBossId].hp, playerStamina = 100;
        let isDodging = false, canDodge = true, canAttack = true;
        let playerHealthBar, bossHealthBar, staminaBar, playerHealthText, bossHealthText, staminaText;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let bossNextAttackTime = 0;
        
        // Dash variables
        let isDashing = false;
        let dashDirection = { x: 0, y: 0 };
        let dashTimer = 0;
        const DASH_DURATION = 200; // ms
        const DASH_SPEED = 800;
        const DASH_COOLDOWN = 1000; // ms
        const DASH_STAMINA_COST = 40;
        let lastDashTime = 0;
        let isInvulnerable = false;
        
        // Charge attack variables
        let isCharging = false;
        let chargeStartTime = 0;
        const CHARGE_TIME = 1500; // ms for full charge
        const MAX_CHARGE_DAMAGE = 50;
        let chargeIndicator = null;
        let chargeLevel = 0;
        let isChargingAttack = false;
        
        // Mobile controls
        let moveJoy = { active: false, deltaX: 0, deltaY: 0 };
        let aimJoy = { active: false, angle: 0 };
        let projectiles = [];
        let bossProjectiles = [];
        
        // Desktop controls
        let leftMouseDown = false;
        let rightMouseDown = false;
        let mouseX = 0, mouseY = 0;
        let aimStartX = 0, aimStartY = 0;
        let aimIndicator = null;

        // Dash button for mobile
        let dashButton = null;
        
        // Stamina warning text
        let staminaWarning = null;

        function create() {
            const width = this.cameras.main.width;
            const height = this.cameras.main.height;
            
            // Grille NEON animÃ©e (responsive)
            let bossData = BOSSES[currentBossId];
            const g = this.add.graphics();
            g.lineStyle(1, bossData.color, 0.15);
            
            for (let i = 0; i < width; i += 50) {
                g.lineBetween(i, 0, i, height);
            }
            for (let i = 0; i < height; i += 50) {
                g.lineBetween(0, i, width, i);
            }
            
            // Particles ambiantes
            for (let i = 0; i < 50; i++) {
                const x = Phaser.Math.Between(0, width);
                const y = Phaser.Math.Between(0, height);
                const size = Phaser.Math.Between(1, 3);
                const color = Phaser.Math.RND.pick([0x00d4ff, bossData.color]);
                const particle = this.add.circle(x, y, size, color, 0.5);
                
                this.tweens.add({
                    targets: particle,
                    y: y + Phaser.Math.Between(-30, 30),
                    alpha: 0.2,
                    duration: Phaser.Math.Between(2000, 4000),
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            }

            // Joueur avec GLOW (position responsive)
            const playerX = width * 0.15;
            const playerY = height * 0.5;
            
            player = this.add.circle(playerX, playerY, 20, 0x00d4ff);
            this.physics.add.existing(player);
            player.body.setCollideWorldBounds(true);
            
            // Double glow effect
            player.glow1 = this.add.circle(playerX, playerY, 40, 0x00d4ff, 0.4);
            player.glow2 = this.add.circle(playerX, playerY, 60, 0x00d4ff, 0.2);
            
            this.tweens.add({
                targets: player.glow1,
                scale: 1.3,
                alpha: 0.15,
                duration: 1200,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
            
            this.tweens.add({
                targets: player.glow2,
                scale: 1.5,
                alpha: 0.05,
                duration: 1800,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });

            // Boss
            bossData = BOSSES[currentBossId];
            const bossX = width * 0.85;
            const bossY = height * 0.5;
            
            boss = this.add.container(bossX, bossY);
            
            if (currentBossId === 1) {
                boss.add([
                    this.add.rectangle(0, 0, 70, 100, bossData.color),
                    this.add.circle(0, -60, 30, bossData.color)
                ]);
            } else if (currentBossId === 2) {
                boss.add([
                    this.add.star(0, 0, 6, 20, 40, bossData.color),
                    this.add.circle(0, 0, 12, 0xffffff)
                ]);
            } else if (currentBossId === 3) {
                const tri = this.add.triangle(0, 0, 0, -40, -35, 35, 35, 35, bossData.color);
                boss.add(tri);
            }
            
            this.physics.add.existing(boss);
            boss.body.setSize(70, 130);
            boss.body.setCollideWorldBounds(true);
            boss.body.immovable = true;
            
            // Boss glow pulsant
            boss.glow1 = this.add.circle(bossX, bossY, 90, bossData.color, 0.3);
            boss.glow2 = this.add.circle(bossX, bossY, 120, bossData.color, 0.15);
            boss.glow1.setDepth(-1);
            boss.glow2.setDepth(-2);
            
            this.tweens.add({
                targets: boss.glow1,
                scale: 1.2,
                alpha: 0.1,
                duration: 1500,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
            
            this.tweens.add({
                targets: boss.glow2,
                scale: 1.4,
                alpha: 0.05,
                duration: 2000,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });

            // UI
            this.add.text(width * 0.5, height * 0.05, bossData.name, { 
                fontSize: Math.min(28, height * 0.04) + 'px', 
                fill: '#' + bossData.color.toString(16).padStart(6, '0'), 
                fontStyle: 'bold' 
            }).setOrigin(0.5);
            
            // Player health
            this.add.text(width * 0.02, height * 0.02, 'VOUS', { 
                fontSize: Math.min(18, height * 0.025) + 'px', 
                fill: '#00d4ff', 
                fontStyle: 'bold' 
            });
            
            playerHealthBar = this.add.rectangle(width * 0.02, height * 0.06, width * 0.3, height * 0.03, 0x1a1a2e)
                .setOrigin(0, 0.5).setStrokeStyle(3, 0x333355);
            playerHealthText = this.add.rectangle(width * 0.02, height * 0.06, width * 0.3, height * 0.03, 0x00ff88)
                .setOrigin(0, 0.5);
            
            // Stamina
            this.add.text(width * 0.02, height * 0.09, 'STAMINA', { 
                fontSize: Math.min(14, height * 0.02) + 'px', 
                fill: '#ffaa00' 
            });
            staminaBar = this.add.rectangle(width * 0.02, height * 0.12, width * 0.2, height * 0.02, 0x1a1a2e)
                .setOrigin(0, 0.5).setStrokeStyle(2, 0x333355);
            staminaText = this.add.rectangle(width * 0.02, height * 0.12, width * 0.2, height * 0.02, 0xffaa00)
                .setOrigin(0, 0.5);

            // Stamina warning text (initially hidden)
            staminaWarning = this.add.text(width * 0.5, height * 0.2, 'âš ï¸ PAS ASSEZ DE STAMINA âš ï¸', {
                fontSize: Math.min(20, height * 0.03) + 'px',
                fill: '#ff0000',
                stroke: '#000',
                strokeThickness: 4,
                backgroundColor: '#00000099',
                padding: { x: 20, y: 10 }
            }).setOrigin(0.5).setVisible(false);

            // Boss health
            this.add.text(width * 0.68, height * 0.07, 'BOSS', { 
                fontSize: Math.min(14, height * 0.02) + 'px', 
                fill: '#' + bossData.color.toString(16).padStart(6, '0') 
            });
            bossHealthBar = this.add.rectangle(width * 0.68, height * 0.1, width * 0.3, height * 0.03, 0x1a1a2e)
                .setOrigin(0, 0.5).setStrokeStyle(3, 0x333355);
            bossHealthText = this.add.rectangle(width * 0.68, height * 0.1, width * 0.3, height * 0.03, bossData.color)
                .setOrigin(0, 0.5);

            // Charge indicator
            chargeIndicator = this.add.graphics();
            chargeIndicator.setDepth(1000);

            if (isMobile) {
                createMobileControls(this);
                createMobileDashButton(this);
            } else {
                createDesktopControls(this);
                this.input.keyboard.on('keydown-SPACE', () => {
                    performDash(this);
                });
            }

            const instructions = isMobile ? 'Gauche: Bouger | Droite: Tirer | Dash: Bouton haut-droit (40 stamina)' 
                : 'Clic Gauche: Aller vers souris | Clic Droit: Viser & Tirer | ESPACE: Dash (40 stamina) | Maintenir Clic Droit: Charge';
            this.add.text(width * 0.5, height * 0.95, instructions, { 
                fontSize: Math.min(13, height * 0.018) + 'px', 
                fill: '#aaa', 
                backgroundColor: '#00000099', 
                padding: { x: 15, y: 8 }
            }).setOrigin(0.5);
        }

        // Mobile dash button
        function createMobileDashButton(scene) {
            const width = scene.cameras.main.width;
            const height = scene.cameras.main.height;
            
            dashButton = scene.add.container(width - 100, 100);
            
            const bg = scene.add.circle(0, 0, 40, 0x00d4ff, 0.3);
            bg.setStrokeStyle(3, 0x00d4ff);
            
            const icon = scene.add.text(0, 0, 'âš¡', { 
                fontSize: '32px', 
                fill: '#00d4ff',
                fontStyle: 'bold'
            }).setOrigin(0.5);
            
            const costText = scene.add.text(0, 25, '40', { 
                fontSize: '12px', 
                fill: '#ffaa00',
                fontStyle: 'bold'
            }).setOrigin(0.5);
            
            const cooldownOverlay = scene.add.circle(0, 0, 40, 0x000000, 0);
            cooldownOverlay.setStrokeStyle(2, 0xff0000);
            
            dashButton.add([bg, icon, costText, cooldownOverlay]);
            dashButton.setSize(80, 80);
            dashButton.setInteractive({ useHandCursor: true });
            
            dashButton.on('pointerdown', () => {
                performDash(scene);
            });
            
            dashButton.cooldownOverlay = cooldownOverlay;
            dashButton.bg = bg;
            dashButton.icon = icon;
        }

        function createDesktopControls(scene) {
            aimIndicator = scene.add.graphics();
            aimIndicator.setDepth(500);
            
            scene.input.mouse.disableContextMenu();
            
            scene.input.on('pointerdown', (pointer) => {
                if (pointer.leftButtonDown()) {
                    leftMouseDown = true;
                    mouseX = pointer.x;
                    mouseY = pointer.y;
                }
                
                if (pointer.rightButtonDown()) {
                    rightMouseDown = true;
                    aimStartX = player.x;
                    aimStartY = player.y;
                    mouseX = pointer.x;
                    mouseY = pointer.y;
                    
                    if (!isDashing && playerStamina >= 30) {
                        startCharge(scene);
                    }
                }
            });
            
            scene.input.on('pointermove', (pointer) => {
                mouseX = pointer.x;
                mouseY = pointer.y;
                
                if (isChargingAttack) {
                    chargeLevel = Math.min(1, (Date.now() - chargeStartTime) / CHARGE_TIME);
                }
            });
            
            scene.input.on('pointerup', (pointer) => {
                if (pointer.button === 0) {
                    leftMouseDown = false;
                }
                
                if (pointer.button === 2) {
                    if (isChargingAttack) {
                        releaseCharge(scene);
                    } else if (rightMouseDown && canAttack && playerStamina >= 20) {
                        const angle = Math.atan2(mouseY - aimStartY, mouseX - aimStartX);
                        shootProjectile(scene, angle);
                    }
                    rightMouseDown = false;
                }
            });
        }

        // Start charging
        function startCharge(scene) {
            if (player.body.velocity.x !== 0 || player.body.velocity.y !== 0) {
                return;
            }
            
            isChargingAttack = true;
            chargeStartTime = Date.now();
            chargeLevel = 0;
            
            scene.tweens.add({
                targets: player.glow1,
                alpha: 0.8,
                duration: 200,
                yoyo: true,
                repeat: -1
            });
            
            chargeIndicator.clear();
        }

        // Release charged attack
        function releaseCharge(scene) {
            if (!isChargingAttack) return;
            
            isChargingAttack = false;
            
            scene.tweens.killTweensOf(player.glow1);
            player.glow1.alpha = 0.4;
            
            if (chargeLevel < 0.3) {
                const angle = Math.atan2(mouseY - aimStartY, mouseX - aimStartX);
                shootProjectile(scene, angle);
                return;
            }
            
            const damage = 18 + Math.floor(chargeLevel * MAX_CHARGE_DAMAGE);
            const angle = Math.atan2(mouseY - aimStartY, mouseX - aimStartX);
            
            playerStamina -= 30;
            
            for (let i = -1; i <= 1; i++) {
                const spreadAngle = angle + (i * 0.2);
                shootChargedProjectile(scene, spreadAngle, damage, chargeLevel);
            }
            
            // Subtle flash instead of intense one
            scene.cameras.main.flash(100, 255, 255, 255, false);
            
            // CHANGED: Reduced shake by half
            scene.cameras.main.shake(100 * chargeLevel, 0.005 * chargeLevel);
            
            chargeLevel = 0;
            chargeIndicator.clear();
        }

        // Charged projectile
        function shootChargedProjectile(scene, angle, damage, chargeLevel) {
            const speed = 750 + (chargeLevel * 300);
            const size = 10 + (chargeLevel * 15);
            const startX = player.x + Math.cos(angle) * 30;
            const startY = player.y + Math.sin(angle) * 30;
            
            const flash = scene.add.circle(startX, startY, 30 * chargeLevel + 20, 0xffffff, 0.9);
            scene.tweens.add({
                targets: flash,
                scale: 3,
                alpha: 0,
                duration: 200,
                onComplete: () => flash.destroy()
            });
            
            const proj = scene.add.circle(startX, startY, size, 0x66ffff);
            proj.setDepth(150);
            proj.vx = Math.cos(angle) * speed;
            proj.vy = Math.sin(angle) * speed;
            proj.damage = damage;
            
            const projGlow = scene.add.circle(startX, startY, size * 2, 0x66ffff, 0.6);
            projGlow.setDepth(149);
            proj.glow = projGlow;
            
            projectiles.push(proj);
            
            scene.time.addEvent({
                delay: 20,
                repeat: 100,
                callback: () => {
                    if (!proj.scene) return;
                    
                    if (proj.glow && proj.glow.scene) {
                        proj.glow.x = proj.x;
                        proj.glow.y = proj.y;
                    }
                    
                    const trail = scene.add.circle(proj.x, proj.y, size * 0.7, 0x66ffff, 0.7);
                    trail.setDepth(148);
                    scene.tweens.add({
                        targets: trail,
                        alpha: 0,
                        scale: 0.5,
                        duration: 400,
                        ease: 'Power2',
                        onComplete: () => trail.destroy()
                    });
                }
            });
            
            scene.time.delayedCall(400, () => canAttack = true);
        }

        function createMobileControls(scene) {
            const width = scene.cameras.main.width;
            const height = scene.cameras.main.height;
            
            const leftZone = scene.add.rectangle(width * 0.25, height * 0.5, width * 0.5, height, 0x0066ff, 0.1);
            const rightZone = scene.add.rectangle(width * 0.75, height * 0.5, width * 0.5, height, 0xff6666, 0.1);
            scene.add.text(width * 0.25, height * 0.1, 'â¬…ï¸ BOUGER', { 
                fontSize: Math.min(18, height * 0.025) + 'px', 
                fill: '#00d4ff', 
                fontStyle: 'bold' 
            }).setOrigin(0.5);
            scene.add.text(width * 0.75, height * 0.1, 'TIRER âž¡ï¸', { 
                fontSize: Math.min(18, height * 0.025) + 'px', 
                fill: '#ff6666', 
                fontStyle: 'bold' 
            }).setOrigin(0.5);
            
            let leftTouch = null, rightTouch = null;
            
            scene.input.addPointer(3);
            
            scene.input.on('pointerdown', (pointer) => {
                if (pointer.x < width * 0.5 && !leftTouch) {
                    leftTouch = {
                        id: pointer.id,
                        startX: pointer.x,
                        startY: pointer.y,
                        base: scene.add.circle(pointer.x, pointer.y, 55, 0x0033aa, 0.7).setDepth(300),
                        thumb: scene.add.circle(pointer.x, pointer.y, 28, 0x00d4ff, 1).setDepth(301)
                    };
                }
                
                if (pointer.x >= width * 0.5 && !rightTouch) {
                    rightTouch = {
                        id: pointer.id,
                        startX: pointer.x,
                        startY: pointer.y,
                        base: scene.add.circle(pointer.x, pointer.y, 55, 0xaa3300, 0.7).setDepth(300),
                        thumb: scene.add.circle(pointer.x, pointer.y, 28, 0xff6666, 1).setDepth(301)
                    };
                }
            });
            
            scene.input.on('pointermove', (pointer) => {
                if (!pointer.isDown) return;
                
                if (leftTouch && pointer.id === leftTouch.id) {
                    const dx = pointer.x - leftTouch.startX;
                    const dy = pointer.y - leftTouch.startY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const max = 55;
                    
                    if (dist < max) {
                        leftTouch.thumb.x = leftTouch.startX + dx;
                        leftTouch.thumb.y = leftTouch.startY + dy;
                        moveJoy.deltaX = dx / max;
                        moveJoy.deltaY = dy / max;
                    } else {
                        const angle = Math.atan2(dy, dx);
                        leftTouch.thumb.x = leftTouch.startX + Math.cos(angle) * max;
                        leftTouch.thumb.y = leftTouch.startY + Math.sin(angle) * max;
                        moveJoy.deltaX = Math.cos(angle);
                        moveJoy.deltaY = Math.sin(angle);
                    }
                    moveJoy.active = true;
                }
                
                if (rightTouch && pointer.id === rightTouch.id) {
                    const dx = pointer.x - rightTouch.startX;
                    const dy = pointer.y - rightTouch.startY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const max = 55;
                    
                    if (dist < max) {
                        rightTouch.thumb.x = rightTouch.startX + dx;
                        rightTouch.thumb.y = rightTouch.startY + dy;
                    } else {
                        const angle = Math.atan2(dy, dx);
                        rightTouch.thumb.x = rightTouch.startX + Math.cos(angle) * max;
                        rightTouch.thumb.y = rightTouch.startY + Math.sin(angle) * max;
                    }
                    
                    aimJoy.angle = Math.atan2(dy, dx);
                    aimJoy.active = dist > 15;
                }
            });
            
            scene.input.on('pointerup', (pointer) => {
                if (leftTouch && pointer.id === leftTouch.id) {
                    leftTouch.base.destroy();
                    leftTouch.thumb.destroy();
                    leftTouch = null;
                    moveJoy.active = false;
                    moveJoy.deltaX = 0;
                    moveJoy.deltaY = 0;
                }
                
                if (rightTouch && pointer.id === rightTouch.id) {
                    if (aimJoy.active && canAttack && playerStamina >= 20) {
                        shootProjectile(scene, aimJoy.angle);
                    }
                    rightTouch.base.destroy();
                    rightTouch.thumb.destroy();
                    rightTouch = null;
                    aimJoy.active = false;
                }
            });
        }

        // Dash function
        function performDash(scene) {
            const now = Date.now();
            
            if (now - lastDashTime < DASH_COOLDOWN) {
                if (dashButton) {
                    scene.tweens.add({
                        targets: dashButton.bg,
                        alpha: 0.1,
                        duration: 100,
                        yoyo: true
                    });
                }
                return;
            }
            
            if (playerStamina < DASH_STAMINA_COST) {
                showStaminaWarning(scene);
                
                scene.tweens.add({
                    targets: staminaBar,
                    fillColor: 0xff0000,
                    duration: 100,
                    yoyo: true,
                    onComplete: () => staminaBar.fillColor = 0x1a1a2e
                });
                return;
            }
            
            let dx = 0, dy = 0;
            
            if (isMobile && moveJoy.active) {
                dx = moveJoy.deltaX;
                dy = moveJoy.deltaY;
            } else {
                const angle = Math.atan2(mouseY - player.y, mouseX - player.x);
                dx = Math.cos(angle);
                dy = Math.sin(angle);
            }
            
            if (dx === 0 && dy === 0) {
                dx = 1;
            }
            
            const length = Math.sqrt(dx*dx + dy*dy);
            dx /= length;
            dy /= length;
            
            isDashing = true;
            isInvulnerable = true;
            lastDashTime = now;
            playerStamina -= DASH_STAMINA_COST;
            
            dashDirection.x = dx;
            dashDirection.y = dy;
            dashTimer = 0;
            
            player.glow1.setScale(2);
            player.glow2.setScale(2.5);
            
            createDashTrail(scene);
            
            updateStaminaBar();
            
            if (dashButton) {
                dashButton.cooldownOverlay.fillColor = 0xff0000;
                dashButton.cooldownOverlay.fillAlpha = 0.5;
                
                scene.time.delayedCall(DASH_COOLDOWN, () => {
                    dashButton.cooldownOverlay.fillAlpha = 0;
                });
            }
        }

        // Show stamina warning
        function showStaminaWarning(scene) {
            if (staminaWarning) {
                staminaWarning.setVisible(true);
                staminaWarning.setAlpha(1);
                
                scene.tweens.add({
                    targets: staminaWarning,
                    alpha: 0,
                    duration: 1000,
                    ease: 'Power2',
                    onComplete: () => staminaWarning.setVisible(false)
                });
            }
        }

        // Create dash trail effect
        function createDashTrail(scene) {
            let trailCount = 0;
            const trailInterval = setInterval(() => {
                if (!isDashing || trailCount > 10) {
                    clearInterval(trailInterval);
                    return;
                }
                
                const trail = scene.add.circle(player.x, player.y, 20, 0x00d4ff, 0.5);
                trail.setDepth(50);
                
                scene.tweens.add({
                    targets: trail,
                    alpha: 0,
                    scale: 2,
                    duration: 300,
                    onComplete: () => trail.destroy()
                });
                
                trailCount++;
            }, 50);
        }

        function update(time, delta) {
            if (playerHealth <= 0 || bossHealth <= 0) {
                handleGameOver(this);
                return;
            }

            const width = this.cameras.main.width;
            const height = this.cameras.main.height;
            const now = Date.now();

            if (isDashing) {
                dashTimer += delta;
                
                player.body.setVelocity(
                    dashDirection.x * DASH_SPEED,
                    dashDirection.y * DASH_SPEED
                );
                
                if (dashTimer >= DASH_DURATION) {
                    isDashing = false;
                    isInvulnerable = false;
                    player.glow1.setScale(1);
                    player.glow2.setScale(1);
                }
            } else {
                const speed = 300;
                let vx = 0, vy = 0;
                
                if (isMobile && moveJoy.active) {
                    vx = moveJoy.deltaX * speed;
                    vy = moveJoy.deltaY * speed;
                }
                
                if (!isMobile && leftMouseDown && !isChargingAttack) {
                    const dx = mouseX - player.x;
                    const dy = mouseY - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 10) {
                        const angle = Math.atan2(dy, dx);
                        vx = Math.cos(angle) * speed;
                        vy = Math.sin(angle) * speed;
                        
                        if (dist < 50) {
                            vx *= (dist / 50);
                            vy *= (dist / 50);
                        }
                    }
                }
                
                player.body.setVelocity(vx, vy);
            }
            
            // Keep player in bounds
            player.x = Phaser.Math.Clamp(player.x, 20, width - 20);
            player.y = Phaser.Math.Clamp(player.y, 20, height - 20);
            
            // Sync player glows
            if (player.glow1) {
                player.glow1.x = player.x;
                player.glow1.y = player.y;
            }
            if (player.glow2) {
                player.glow2.x = player.x;
                player.glow2.y = player.y;
            }
            
            // Keep boss in bounds
            if (boss) {
                boss.x = Phaser.Math.Clamp(boss.x, 100, width - 100);
                boss.y = Phaser.Math.Clamp(boss.y, 100, height - 100);
                
                if (boss.glow1) {
                    boss.glow1.x = boss.x;
                    boss.glow1.y = boss.y;
                }
                if (boss.glow2) {
                    boss.glow2.x = boss.x;
                    boss.glow2.y = boss.y;
                }
            }
            
            // Update charge indicator
            if (isChargingAttack) {
                chargeLevel = Math.min(1, (now - chargeStartTime) / CHARGE_TIME);
                
                chargeIndicator.clear();
                
                const radius = 30 + (chargeLevel * 30);
                chargeIndicator.lineStyle(3, 0xffaa00, 0.8);
                chargeIndicator.strokeCircle(player.x, player.y, radius);
                
                chargeIndicator.fillStyle(0xffaa00, 0.2);
                chargeIndicator.slice(
                    player.x, player.y,
                    radius - 5,
                    0, Math.PI * 2 * chargeLevel,
                    false
                );
                chargeIndicator.fillPath();
            } else {
                chargeIndicator.clear();
            }
            
            // Aim indicator
            if (!isMobile && aimIndicator && !isChargingAttack) {
                aimIndicator.clear();
                
                if (rightMouseDown) {
                    const dx = mouseX - aimStartX;
                    const dy = mouseY - aimStartY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 15) {
                        aimIndicator.lineStyle(3, 0xff6666, 0.8);
                        for (let i = 0; i < dist; i += 15) {
                            const x1 = aimStartX + (dx / dist) * i;
                            const y1 = aimStartY + (dy / dist) * i;
                            const x2 = aimStartX + (dx / dist) * (i + 8);
                            const y2 = aimStartY + (dy / dist) * (i + 8);
                            aimIndicator.lineBetween(x1, y1, x2, y2);
                        }
                        
                        aimIndicator.lineStyle(2, 0xff3333, 1);
                        aimIndicator.strokeCircle(mouseX, mouseY, 10);
                    }
                }
            }

            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                
                proj.x += proj.vx * (delta / 1000);
                proj.y += proj.vy * (delta / 1000);
                
                const dist = Phaser.Math.Distance.Between(proj.x, proj.y, boss.x, boss.y);
                if (dist < 60) {
                    const damage = proj.damage || 18;
                    hitBoss(this, damage);
                    if (proj.glow && proj.glow.scene) proj.glow.destroy();
                    proj.destroy();
                    projectiles.splice(i, 1);
                    continue;
                }
                
                if (proj.x < -50 || proj.x > width + 50 || proj.y < -50 || proj.y > height + 50) {
                    if (proj.glow && proj.glow.scene) proj.glow.destroy();
                    proj.destroy();
                    projectiles.splice(i, 1);
                }
            }

            // Update boss projectiles
            for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                const bProj = bossProjectiles[i];
                
                bProj.x += bProj.vx * (delta / 1000);
                bProj.y += bProj.vy * (delta / 1000);
                
                const distToPlayer = Phaser.Math.Distance.Between(bProj.x, bProj.y, player.x, player.y);
                if (distToPlayer < 25 && !isInvulnerable) {
                    hitPlayer(this, 10);
                    bProj.destroy();
                    bossProjectiles.splice(i, 1);
                    continue;
                }
                
                if (bProj.x < -50 || bProj.x > width + 50 || bProj.y < -50 || bProj.y > height + 50) {
                    bProj.destroy();
                    bossProjectiles.splice(i, 1);
                }
            }

            // CHANGED: Reduced stamina regeneration by half (from 0.45 to 0.225)
            if (playerStamina < 100) {
                playerStamina = Math.min(100, playerStamina + 0.225);
                updateStaminaBar();
            }

            // Boss AI
            if (time > bossNextAttackTime) {
                bossNextAttackTime = time + Phaser.Math.Between(2000, 3500);
                bossAttack(this);
            }

            updateHealthBars();
        }

        function shootProjectile(scene, angle) {
            if (isDashing || isChargingAttack) return;
            
            canAttack = false;
            playerStamina -= 20;
            
            const speed = 750;
            const startX = player.x + Math.cos(angle) * 30;
            const startY = player.y + Math.sin(angle) * 30;
            
            const flash = scene.add.circle(startX, startY, 20, 0xffffff, 0.9);
            scene.tweens.add({
                targets: flash,
                scale: 2,
                alpha: 0,
                duration: 150,
                onComplete: () => flash.destroy()
            });
            
            const proj = scene.add.circle(startX, startY, 10, 0x66ffff);
            proj.setDepth(150);
            proj.vx = Math.cos(angle) * speed;
            proj.vy = Math.sin(angle) * speed;
            
            const projGlow = scene.add.circle(startX, startY, 18, 0x66ffff, 0.6);
            projGlow.setDepth(149);
            proj.glow = projGlow;
            
            projectiles.push(proj);
            
            scene.time.addEvent({
                delay: 30,
                repeat: 60,
                callback: () => {
                    if (!proj.scene) return;
                    
                    if (proj.glow && proj.glow.scene) {
                        proj.glow.x = proj.x;
                        proj.glow.y = proj.y;
                    }
                    
                    const trail = scene.add.circle(proj.x, proj.y, 7, 0x66ffff, 0.7);
                    trail.setDepth(148);
                    scene.tweens.add({
                        targets: trail,
                        alpha: 0,
                        scale: 0.2,
                        duration: 400,
                        ease: 'Power2',
                        onComplete: () => trail.destroy()
                    });
                }
            });
            
            scene.time.delayedCall(400, () => canAttack = true);
        }

        function bossAttack(scene) {
            if (currentBossId === 1) boss1Attack(scene);
            else if (currentBossId === 2) boss2Attack(scene);
            else if (currentBossId === 3) boss3Attack(scene);
        }

        function boss1Attack(scene) {
            const warning = scene.add.rectangle(boss.x - 100, boss.y, 150, 130, 0xff0051, 0.2);
            warning.setStrokeStyle(3, 0xff0051);
            
            scene.tweens.add({
                targets: warning,
                alpha: 0.5,
                duration: 800,
                yoyo: true,
                onComplete: () => {
                    warning.destroy();
                    
                    const slashZone = scene.add.rectangle(boss.x - 100, boss.y, 150, 130, 0xff6666, 0.7);
                    scene.physics.add.existing(slashZone);
                    
                    const dist = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
                    if (dist < 120 && !isInvulnerable) {
                        hitPlayer(scene, 15);
                    }
                    
                    scene.tweens.add({
                        targets: slashZone,
                        alpha: 0,
                        duration: 200,
                        onComplete: () => slashZone.destroy()
                    });
                }
            });
        }

        function boss2Attack(scene) {
            const warning = scene.add.circle(boss.x, boss.y, 35, 0xff6600, 0.3);
            warning.setStrokeStyle(4, 0xff6600);
            
            scene.tweens.add({
                targets: warning,
                radius: 55,
                alpha: 0,
                duration: 700,
                onComplete: () => {
                    warning.destroy();
                    
                    const angleToPlayer = Math.atan2(player.y - boss.y, player.x - boss.x);
                    const spread = Math.PI / 4;
                    
                    for (let i = -2; i <= 2; i++) {
                        const angle = angleToPlayer + (i * spread / 4);
                        const bossProj = scene.add.circle(boss.x, boss.y, 8, 0xff6600);
                        bossProj.setDepth(150);
                        bossProj.vx = Math.cos(angle) * 300;
                        bossProj.vy = Math.sin(angle) * 300;
                        bossProj.isBossProj = true;
                        
                        bossProjectiles.push(bossProj);
                        
                        scene.time.delayedCall(3000, () => {
                            if (bossProj.scene) {
                                const idx = bossProjectiles.indexOf(bossProj);
                                if (idx > -1) bossProjectiles.splice(idx, 1);
                                bossProj.destroy();
                            }
                        });
                    }
                }
            });
        }

        function boss3Attack(scene) {
            const targetX = player.x;
            const targetY = player.y;
            
            const line = scene.add.line(0, 0, boss.x, boss.y, targetX, targetY, 0xcc00ff, 0.6);
            line.setLineWidth(5);
            
            scene.tweens.add({
                targets: line,
                alpha: 0,
                duration: 500,
                onComplete: () => {
                    line.destroy();
                    
                    scene.tweens.add({
                        targets: boss,
                        x: targetX,
                        y: targetY,
                        duration: 150,
                        ease: 'Power3',
                        onComplete: () => {
                            const dist = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
                            if (dist < 70 && !isInvulnerable) {
                                hitPlayer(scene, 20);
                            }
                            
                            // CHANGED: Reduced shake
                            scene.cameras.main.shake(100, 0.005);
                        }
                    });
                }
            });
        }

        function hitBoss(scene, damage) {
            bossHealth = Math.max(0, bossHealth - damage);
            
            scene.physics.pause();
            scene.time.delayedCall(40, () => scene.physics.resume());
            
            const flash = scene.add.rectangle(boss.x, boss.y, 100, 140, 0xffffff, 0.8);
            flash.setDepth(200);
            scene.tweens.add({
                targets: flash,
                alpha: 0,
                duration: 100,
                onComplete: () => flash.destroy()
            });
            
            scene.tweens.add({ targets: boss, alpha: 0.3, duration: 60, yoyo: true });
            
            // Show damage number
            const dmgText = scene.add.text(boss.x, boss.y - 50, damage.toString(), {
                fontSize: Math.min(24, scene.cameras.main.height * 0.03) + 'px',
                fill: '#ffaa00',
                stroke: '#000',
                strokeThickness: 4,
                fontStyle: 'bold'
            }).setOrigin(0.5);
            
            scene.tweens.add({
                targets: dmgText,
                y: boss.y - 100,
                alpha: 0,
                duration: 800,
                ease: 'Power2',
                onComplete: () => dmgText.destroy()
            });
            
            bossData = BOSSES[currentBossId];
            for (let i = 0; i < 20; i++) {
                const angle = (Math.PI * 2 * i) / 20;
                const dist = Phaser.Math.Between(40, 80);
                const size = Phaser.Math.Between(4, 10);
                const p = scene.add.circle(boss.x, boss.y, size, bossData.color);
                p.setDepth(199);
                
                scene.tweens.add({
                    targets: p,
                    x: boss.x + Math.cos(angle) * dist,
                    y: boss.y + Math.sin(angle) * dist,
                    alpha: 0,
                    scale: 0.3,
                    duration: 600,
                    ease: 'Power2',
                    onComplete: () => p.destroy()
                });
            }
            
            const ring = scene.add.circle(boss.x, boss.y, 30, bossData.color, 0);
            ring.setStrokeStyle(4, bossData.color, 0.8);
            ring.setDepth(198);
            scene.tweens.add({
                targets: ring,
                radius: 100,
                alpha: 0,
                duration: 400,
                ease: 'Power2',
                onComplete: () => ring.destroy()
            });
            
            // CHANGED: Reduced shake
            scene.cameras.main.shake(80, 0.006);
            
            if (bossHealth <= 0) {
                scene.time.timeScale = 0.3;
                scene.time.delayedCall(400, () => {
                    scene.time.timeScale = 1;
                });
            }
        }

        function hitPlayer(scene, damage) {
            if (isInvulnerable) return;
            
            playerHealth = Math.max(0, playerHealth - damage);
            
            const flash = scene.add.rectangle(player.x, player.y, 60, 60, 0xff0000, 0.6);
            flash.setDepth(200);
            scene.tweens.add({
                targets: flash,
                alpha: 0,
                duration: 150,
                onComplete: () => flash.destroy()
            });
            
            scene.tweens.add({ targets: player, alpha: 0.2, duration: 80, yoyo: true });
            
            for (let i = 0; i < 8; i++) {
                const angle = Phaser.Math.Between(0, 360) * Math.PI / 180;
                const p = scene.add.circle(player.x, player.y, 5, 0xff3355);
                scene.tweens.add({
                    targets: p,
                    x: player.x + Math.cos(angle) * 40,
                    y: player.y + Math.sin(angle) * 40,
                    alpha: 0,
                    duration: 400,
                    onComplete: () => p.destroy()
                });
            }
            
            // CHANGED: Reduced shake
            scene.cameras.main.shake(100, 0.007);
        }

        function updateHealthBars() {
            playerHealthText.width = (playerHealthBar.width) * (playerHealth / 100);
            bossHealthText.width = (bossHealthBar.width) * (bossHealth / BOSSES[currentBossId].hp);
            
            if (playerHealth < 30) playerHealthText.fillColor = 0xff0000;
            else if (playerHealth < 60) playerHealthText.fillColor = 0xffaa00;
            else playerHealthText.fillColor = 0x00ff88;
        }

        function updateStaminaBar() {
            staminaText.width = staminaBar.width * (playerStamina / 100);
        }

        function handleGameOver(scene) {
            const width = scene.cameras.main.width;
            const height = scene.cameras.main.height;
            
            scene.physics.pause();
            const isVictory = bossHealth <= 0;
            const msg = isVictory ? 'âœ¨ VICTOIRE âœ¨' : 'ðŸ’€ DÃ‰FAITE ðŸ’€';
            const color = isVictory ? '#00ff88' : '#ff3355';
            
            if (isVictory && currentBossId === unlockedBosses && currentBossId < 3) {
                unlockedBosses++;
                localStorage.setItem('unlockedBosses', unlockedBosses);
            }
            
            const txt = scene.add.text(width * 0.5, height * 0.4, msg, { 
                fontSize: Math.min(64, height * 0.1) + 'px', 
                fill: color, 
                fontStyle: 'bold', 
                stroke: '#000', 
                strokeThickness: 6 
            }).setOrigin(0.5);
            
            scene.tweens.add({ targets: txt, scale: 1.15, duration: 600, yoyo: true, repeat: -1 });
            
            scene.add.text(width * 0.5, height * 0.5, BOSSES[currentBossId].name + ' VAINCU!', {
                fontSize: Math.min(20, height * 0.03) + 'px',
                fill: '#888'
            }).setOrigin(0.5).setVisible(isVictory);
            
            const retryBtn = scene.add.text(width * 0.4, height * 0.6, '[RETRY]', { 
                fontSize: Math.min(24, height * 0.035) + 'px', 
                fill: '#00d4ff', 
                backgroundColor: '#00000099', 
                padding: { x: 20, y: 10 }
            }).setOrigin(0.5).setInteractive({ useHandCursor: true });
            
            retryBtn.on('pointerdown', () => {
                scene.scene.restart();
                playerHealth = 100;
                bossHealth = BOSSES[currentBossId].hp;
                playerStamina = 100;
                projectiles = [];
                bossProjectiles = [];
            });
            
            const selectBtn = scene.add.text(width * 0.6, height * 0.6, '[SELECT BOSS]', { 
                fontSize: Math.min(24, height * 0.035) + 'px', 
                fill: '#ff6600', 
                backgroundColor: '#00000099', 
                padding: { x: 20, y: 10 }
            }).setOrigin(0.5).setInteractive({ useHandCursor: true });
            
            selectBtn.on('pointerdown', () => showBossSelect(scene));
            
            if (isVictory && currentBossId < unlockedBosses) {
                const nextBtn = scene.add.text(width * 0.5, height * 0.7, 'â†’ NEXT BOSS', { 
                    fontSize: Math.min(20, height * 0.03) + 'px', 
                    fill: '#00ff88', 
                    backgroundColor: '#00000099', 
                    padding: { x: 15, y: 8 }
                }).setOrigin(0.5).setInteractive({ useHandCursor: true });
                
                nextBtn.on('pointerdown', () => {
                    currentBossId++;
                    localStorage.setItem('currentBoss', currentBossId);
                    scene.scene.restart();
                    playerHealth = 100;
                    bossHealth = BOSSES[currentBossId].hp;
                    playerStamina = 100;
                    projectiles = [];
                    bossProjectiles = [];
                });
            }
        }

        function showBossSelect(scene) {
            const width = scene.cameras.main.width;
            const height = scene.cameras.main.height;
            
            scene.children.removeAll();
            
            scene.add.text(width * 0.5, height * 0.1, 'SELECT BOSS', {
                fontSize: Math.min(48, height * 0.08) + 'px',
                fill: '#00d4ff',
                fontStyle: 'bold'
            }).setOrigin(0.5);
            
            const startX = width * 0.2;
            const spacing = width * 0.25;
            
            [1, 2, 3].forEach((bossId, index) => {
                const bossData = BOSSES[bossId];
                const x = startX + (index * spacing);
                const y = height * 0.5;
                const unlocked = bossId <= unlockedBosses;
                
                const card = scene.add.rectangle(x, y, width * 0.15, height * 0.3, 0x1a1a2e, unlocked ? 0.8 : 0.3);
                card.setStrokeStyle(3, bossData.color, unlocked ? 1 : 0.3);
                
                if (unlocked) {
                    card.setInteractive({ useHandCursor: true });
                    
                    card.on('pointerover', () => {
                        scene.tweens.add({ targets: card, scaleX: 1.05, scaleY: 1.05, duration: 200 });
                    });
                    
                    card.on('pointerout', () => {
                        scene.tweens.add({ targets: card, scaleX: 1, scaleY: 1, duration: 200 });
                    });
                    
                    card.on('pointerdown', () => {
                        currentBossId = bossId;
                        localStorage.setItem('currentBoss', currentBossId);
                        scene.scene.restart();
                        playerHealth = 100;
                        bossHealth = BOSSES[currentBossId].hp;
                        playerStamina = 100;
                        projectiles = [];
                        bossProjectiles = [];
                    });
                }
                
                const preview = scene.add.circle(x, y - height * 0.07, height * 0.05, bossData.color, unlocked ? 1 : 0.3);
                const glow = scene.add.circle(x, y - height * 0.07, height * 0.07, bossData.color, unlocked ? 0.3 : 0.1);
                
                scene.add.text(x, y + height * 0.05, bossData.name, {
                    fontSize: Math.min(18, height * 0.025) + 'px',
                    fill: unlocked ? '#fff' : '#444',
                    fontStyle: 'bold'
                }).setOrigin(0.5);
                
                scene.add.text(x, y + height * 0.1, 'HP: ' + bossData.hp, {
                    fontSize: Math.min(14, height * 0.02) + 'px',
                    fill: unlocked ? '#ffaa00' : '#333'
                }).setOrigin(0.5);
                
                if (!unlocked) {
                    scene.add.text(x, y, 'ðŸ”’', { fontSize: Math.min(32, height * 0.04) + 'px' }).setOrigin(0.5);
                }
            });
        }

        window.addEventListener('load', () => { 
            game = new Phaser.Game(config); 
        });
    </script>
</body>
</html>