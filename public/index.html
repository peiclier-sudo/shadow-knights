<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shadow Knights - Boss Rush SMOOTH</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        * { margin: 0; padding: 0; overflow: hidden; }
        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a1a 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #game-container { box-shadow: 0 0 60px rgba(0,212,255,0.4); }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
        const config = {
            type: Phaser.AUTO,
            width: 1000,
            height: 700,
            parent: 'game-container',
            backgroundColor: '#0f0f1e',
            physics: { default: 'arcade', arcade: { gravity: { y: 0 }}},
            scene: { create, update },
            scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH }
        };

        let game, player, boss, projectiles;
        let cursors, keys, playerHealth = 100, bossHealth = 500, playerStamina = 100;
        let isDodging = false, canDodge = true, canAttack = true;
        let playerHealthBar, bossHealthBar, staminaBar, playerHealthText, bossHealthText, staminaText;
        let virtualJoystick, aimJoystick, dodgeButton;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let bossNextAttackTime = 0, damageDealt = 0, dodgesPerformed = 0;
        let aimAngle = 0, isAiming = false, aimIndicator;

        function create() {
            // Grille
            const g = this.add.graphics();
            g.lineStyle(1, 0x1a1a2e, 0.4);
            for (let i = 0; i < 1000; i += 50) g.lineBetween(i, 0, i, 700);
            for (let i = 0; i < 700; i += 50) g.lineBetween(0, i, 1000, i);

            // Joueur
            player = this.add.circle(150, 350, 22, 0x00d4ff);
            this.physics.add.existing(player);
            player.body.setCollideWorldBounds(true);
            player.direction = 1;
            player.glow = this.add.circle(150, 350, 35, 0x00d4ff, 0.3);
            
            // Indicateur de vis√©e (ligne pointill√©e)
            aimIndicator = this.add.graphics();
            aimIndicator.setDepth(10);

            // Boss
            boss = this.add.container(850, 350);
            boss.add([
                this.add.rectangle(0, 0, 70, 100, 0xff0051),
                this.add.circle(0, -60, 30, 0xff0051)
            ]);
            this.physics.add.existing(boss);
            boss.body.setSize(70, 130);
            boss.body.setCollideWorldBounds(true);
            boss.body.immovable = true;
            boss.glow = this.add.circle(850, 350, 90, 0xff0051, 0.2);
            boss.isAttacking = false;

            projectiles = this.physics.add.group();
            this.physics.add.overlap(player, projectiles, hitPlayerProjectile, null, this);

            // Contr√¥les
            cursors = this.input.keyboard.createCursorKeys();
            keys = {
                space: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE),
                shift: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT),
                E: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E),
                Z: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Z),
                Q: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q),
                S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),
                D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)
            };
            
            // Clic droit pour viser (desktop)
            this.input.on('pointerdown', (pointer) => {
                if (!isMobile && pointer.rightButtonDown()) {
                    isAiming = true;
                    const dx = pointer.x - player.x;
                    const dy = pointer.y - player.y;
                    aimAngle = Math.atan2(dy, dx);
                }
            });
            
            this.input.on('pointermove', (pointer) => {
                if (!isMobile && isAiming && pointer.rightButtonDown()) {
                    const dx = pointer.x - player.x;
                    const dy = pointer.y - player.y;
                    aimAngle = Math.atan2(dy, dx);
                }
            });
            
            this.input.on('pointerup', (pointer) => {
                if (!isMobile && pointer.button === 2 && isAiming) {
                    // Tirer en rel√¢chant le clic droit
                    if (canAttack && playerStamina >= 20) {
                        performRangedAttack(this);
                    }
                    isAiming = false;
                }
            });
            
            // D√©sactiver le menu contextuel du clic droit
            this.input.mouse.disableContextMenu();

            // UI
            this.add.text(20, 20, 'CHEVALIER', { fontSize: '20px', fill: '#00d4ff', fontStyle: 'bold' });
            playerHealthBar = this.add.rectangle(20, 60, 400, 28, 0x1a1a2e).setOrigin(0, 0.5).setStrokeStyle(3, 0x333355);
            playerHealthText = this.add.rectangle(20, 60, 400, 28, 0x00ff88).setOrigin(0, 0.5);
            
            this.add.text(20, 88, 'STAMINA', { fontSize: '14px', fill: '#ffaa00' });
            staminaBar = this.add.rectangle(20, 110, 280, 16, 0x1a1a2e).setOrigin(0, 0.5).setStrokeStyle(2, 0x333355);
            staminaText = this.add.rectangle(20, 110, 280, 16, 0xffaa00).setOrigin(0, 0.5);

            this.add.text(600, 20, 'SEIGNEUR DES OMBRES', { fontSize: '22px', fill: '#ff0051', fontStyle: 'bold' });
            bossHealthBar = this.add.rectangle(600, 65, 380, 30, 0x1a1a2e).setOrigin(0, 0.5).setStrokeStyle(3, 0x333355);
            bossHealthText = this.add.rectangle(600, 65, 380, 30, 0xff0051).setOrigin(0, 0.5);

            if (isMobile) createMobileControls(this);

            const instructions = isMobile ? 'Joystick gauche: Bouger | Joystick droit: Viser & Tirer | ROLL: Dash' 
                : 'ZQSD: Bouger | CLIC DROIT: Viser & Tirer | SHIFT: Dash';
            this.add.text(500, 680, instructions, { fontSize: '13px', fill: '#aaa', backgroundColor: '#00000099', padding: { x: 15, y: 8 }}).setOrigin(0.5);
        }

        function createMobileControls(scene) {
            // JOYSTICK GAUCHE - D√©placement
            const jBase = scene.add.circle(120, 580, 65, 0x2a2a3e, 0.7);
            const jThumb = scene.add.circle(120, 580, 32, 0x00d4ff, 0.95);
            virtualJoystick = { base: jBase, thumb: jThumb, active: false, startX: 120, startY: 580, deltaX: 0, deltaY: 0 };
            
            jBase.setInteractive().on('pointerdown', () => virtualJoystick.active = true);
            scene.input.on('pointermove', pointer => {
                // Joystick de d√©placement
                if (virtualJoystick.active && pointer.isDown && pointer.x < 500) {
                    const dx = pointer.x - 120, dy = pointer.y - 580, dist = Math.sqrt(dx*dx + dy*dy), max = 65;
                    if (dist < max) {
                        jThumb.x = 120 + dx; jThumb.y = 580 + dy;
                        virtualJoystick.deltaX = dx/max; virtualJoystick.deltaY = dy/max;
                    } else {
                        const angle = Math.atan2(dy, dx);
                        jThumb.x = 120 + Math.cos(angle)*max; jThumb.y = 580 + Math.sin(angle)*max;
                        virtualJoystick.deltaX = Math.cos(angle); virtualJoystick.deltaY = Math.sin(angle);
                    }
                }
                
                // Joystick de vis√©e (c√¥t√© droit)
                if (aimJoystick && aimJoystick.active && pointer.isDown && pointer.x > 500) {
                    const dx = pointer.x - 880, dy = pointer.y - 580;
                    const angle = Math.atan2(dy, dx);
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const max = 65;
                    
                    if (dist < max) {
                        aimJoystick.thumb.x = 880 + dx;
                        aimJoystick.thumb.y = 580 + dy;
                    } else {
                        aimJoystick.thumb.x = 880 + Math.cos(angle)*max;
                        aimJoystick.thumb.y = 580 + Math.sin(angle)*max;
                    }
                    
                    aimAngle = angle;
                    isAiming = dist > 10; // Deadzone
                }
            });
            
            scene.input.on('pointerup', (pointer) => {
                if (pointer.x < 500) {
                    virtualJoystick.active = false; 
                    jThumb.x = 120; jThumb.y = 580;
                    virtualJoystick.deltaX = 0; virtualJoystick.deltaY = 0;
                }
                
                if (pointer.x > 500 && aimJoystick) {
                    // Tirer quand on rel√¢che le joystick de vis√©e
                    if (isAiming && canAttack && playerStamina >= 20) {
                        performRangedAttack(scene);
                    }
                    aimJoystick.active = false;
                    aimJoystick.thumb.x = 880;
                    aimJoystick.thumb.y = 580;
                    isAiming = false;
                }
            });

            // JOYSTICK DROIT - Vis√©e et tir
            const aimBase = scene.add.circle(880, 580, 65, 0x2a2a3e, 0.7);
            const aimThumb = scene.add.circle(880, 580, 32, 0xff6b6b, 0.95);
            scene.add.text(880, 630, 'AIM & SHOOT', { fontSize: '11px', fill: '#ff6b6b', fontStyle: 'bold' }).setOrigin(0.5);
            aimJoystick = { base: aimBase, thumb: aimThumb, active: false };
            
            aimBase.setInteractive().on('pointerdown', () => {
                aimJoystick.active = true;
            });

            // Bouton d'esquive (en haut √† droite)
            dodgeButton = scene.add.circle(920, 480, 43, 0x00d4ff, 0.85).setInteractive().setStrokeStyle(4, 0x00aacc);
            scene.add.text(920, 480, 'ROLL', { fontSize: '15px', fill: '#fff', fontStyle: 'bold' }).setOrigin(0.5);
            dodgeButton.on('pointerdown', () => { if (canDodge && playerStamina >= 25) performDodge(scene); });
        }

        function update(time) {
            if (playerHealth <= 0 || bossHealth <= 0) { handleGameOver(this); return; }

            let vx = 0, vy = 0;
            const speed = isDodging ? 500 : 220;
            if (cursors.left.isDown || keys.Q.isDown) { vx = -speed; player.direction = -1; }
            else if (cursors.right.isDown || keys.D.isDown) { vx = speed; player.direction = 1; }
            if (cursors.up.isDown || keys.Z.isDown) vy = -speed;
            else if (cursors.down.isDown || keys.S.isDown) vy = speed;

            if (virtualJoystick && virtualJoystick.active) {
                vx = virtualJoystick.deltaX * speed; vy = virtualJoystick.deltaY * speed;
                if (vx !== 0) player.direction = vx > 0 ? 1 : -1;
            }
            player.body.setVelocity(vx, vy);
            player.glow.x = player.x; player.glow.y = player.y;
            
            // Indicateur de vis√©e
            aimIndicator.clear();
            if (isAiming) {
                const aimLength = 100;
                const targetX = player.x + Math.cos(aimAngle) * aimLength;
                const targetY = player.y + Math.sin(aimAngle) * aimLength;
                
                // Ligne pointill√©e
                aimIndicator.lineStyle(3, 0xff6666, 0.8);
                for (let i = 0; i < aimLength; i += 10) {
                    const x1 = player.x + Math.cos(aimAngle) * i;
                    const y1 = player.y + Math.sin(aimAngle) * i;
                    const x2 = player.x + Math.cos(aimAngle) * (i + 5);
                    const y2 = player.y + Math.sin(aimAngle) * (i + 5);
                    aimIndicator.lineBetween(x1, y1, x2, y2);
                }
                
                // Cercle cible
                aimIndicator.lineStyle(2, 0xff3333, 0.9);
                aimIndicator.strokeCircle(targetX, targetY, 8);
            }

            if (Phaser.Input.Keyboard.JustDown(keys.space) && canAttack && !isDodging && playerStamina >= 15) performMeleeAttack(this);
            if (Phaser.Input.Keyboard.JustDown(keys.E) && canAttack && !isDodging && playerStamina >= 20) performRangedAttack(this);
            if (Phaser.Input.Keyboard.JustDown(keys.shift) && canDodge && playerStamina >= 25) performDodge(this);

            if (playerStamina < 100 && !isDodging) {
                playerStamina = Math.min(100, playerStamina + 0.4);
                updateStaminaBar();
            }

            if (time > bossNextAttackTime && !boss.isAttacking) {
                bossNextAttackTime = time + Phaser.Math.Between(2500, 4000);
                executeBossAttack(this);
            }

            boss.glow.x = boss.x; boss.glow.y = boss.y;
            updateHealthBars();
        }

        function performMeleeAttack(scene) {
            canAttack = false; playerStamina -= 15;
            scene.tweens.add({ targets: player, x: player.x + player.direction * 80, duration: 120, ease: 'Power2', yoyo: true });
            const slash = scene.add.rectangle(player.x + player.direction * 50, player.y, 40, 15, 0xffff00, 0.9);
            scene.tweens.add({ targets: slash, alpha: 0, scaleX: 1.5, duration: 150, onComplete: () => slash.destroy() });
            const dist = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
            if (dist < 120) hitBoss(scene, 12);
            scene.time.delayedCall(350, () => canAttack = true);
        }

        function performRangedAttack(scene) {
            canAttack = false; playerStamina -= 20;
            
            // Calculer la direction du projectile selon aimAngle
            const projSpeed = 500;
            const startX = player.x + Math.cos(aimAngle) * 30;
            const startY = player.y + Math.sin(aimAngle) * 30;
            
            const proj = scene.add.circle(startX, startY, 8, 0x66ffff);
            scene.physics.add.existing(proj);
            proj.body.setVelocity(Math.cos(aimAngle) * projSpeed, Math.sin(aimAngle) * projSpeed);
            proj.damage = 18;
            projectiles.add(proj);

            // Trail effect
            for(let i = 0; i < 5; i++) {
                scene.time.delayedCall(i * 40, () => {
                    if (proj.active) {
                        const trail = scene.add.circle(proj.x, proj.y, 6, 0x66ffff, 0.5);
                        scene.tweens.add({ targets: trail, alpha: 0, scale: 0.5, duration: 300, onComplete: () => trail.destroy() });
                    }
                });
            }

            scene.physics.add.overlap(proj, boss, () => { 
                if (proj.active) {
                    hitBoss(scene, proj.damage); 
                    // Impact effect
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI * 2 * i) / 6;
                        const spark = scene.add.circle(proj.x, proj.y, 4, 0x66ffff);
                        scene.tweens.add({
                            targets: spark,
                            x: proj.x + Math.cos(angle) * 30,
                            y: proj.y + Math.sin(angle) * 30,
                            alpha: 0,
                            duration: 300,
                            onComplete: () => spark.destroy()
                        });
                    }
                    proj.destroy();
                }
            });

            scene.time.delayedCall(2500, () => { if (proj.active) proj.destroy(); });
            scene.time.delayedCall(400, () => canAttack = true);
        }

        function performDodge(scene) {
            isDodging = true; canDodge = false; playerStamina -= 25; dodgesPerformed++;
            player.alpha = 0.3;

            const dashDist = 150;
            let dashX = 0, dashY = 0;
            if (cursors.left.isDown || keys.Q.isDown) dashX = -dashDist;
            else if (cursors.right.isDown || keys.D.isDown) dashX = dashDist;
            else dashX = player.direction * dashDist;
            if (cursors.up.isDown || keys.Z.isDown) dashY = -dashDist;
            else if (cursors.down.isDown || keys.S.isDown) dashY = dashDist;

            scene.tweens.add({ targets: player, x: player.x + dashX, y: player.y + dashY, duration: 250, ease: 'Power3', onComplete: () => { isDodging = false; player.alpha = 1; }});

            for (let i = 0; i < 6; i++) {
                scene.time.delayedCall(i * 40, () => {
                    const trail = scene.add.circle(player.x, player.y, 22, 0x00d4ff, 0.25);
                    scene.tweens.add({ targets: trail, alpha: 0, scale: 0.5, duration: 250, onComplete: () => trail.destroy() });
                });
            }

            scene.time.delayedCall(700, () => canDodge = true);
        }

        function executeBossAttack(scene) {
            boss.isAttacking = true;
            const pattern = Phaser.Math.Between(0, 2);
            if (pattern === 0) bossSlashCombo(scene);
            else if (pattern === 1) bossProjectileBarrage(scene);
            else bossGroundSlam(scene);
        }

        function bossSlashCombo(scene) {
            const warning = scene.add.rectangle(boss.x - 120, boss.y, 180, 150, 0xff0051, 0.15).setStrokeStyle(3, 0xff0051, 0.6);
            scene.tweens.add({ targets: warning, alpha: 0.4, duration: 800, yoyo: true, repeat: 1 });

            scene.time.delayedCall(1200, () => {
                warning.destroy();
                const slashZone = scene.add.rectangle(boss.x - 120, boss.y, 180, 150, 0xff6666, 0.6);
                scene.physics.add.existing(slashZone);
                scene.physics.add.overlap(player, slashZone, () => { if (!isDodging) hitPlayer(scene, 15); });
                scene.tweens.add({ targets: slashZone, alpha: 0, duration: 200, onComplete: () => { slashZone.destroy(); boss.isAttacking = false; }});
                scene.cameras.main.shake(150, 0.004);
            });
        }

        function bossProjectileBarrage(scene) {
            const warning = scene.add.circle(boss.x, boss.y, 50, 0xff0051, 0.2).setStrokeStyle(4, 0xff0051, 0.7);
            scene.tweens.add({ targets: warning, radius: 80, alpha: 0, duration: 1000, onComplete: () => warning.destroy() });

            scene.time.delayedCall(1000, () => {
                for (let i = 0; i < 8; i++) {
                    scene.time.delayedCall(i * 150, () => {
                        const angle = (Math.PI * 2 * i / 8);
                        const bossProj = scene.add.circle(boss.x, boss.y, 10, 0xff3366);
                        scene.physics.add.existing(bossProj);
                        bossProj.body.setVelocity(Math.cos(angle) * 280, Math.sin(angle) * 280);
                        bossProj.isBossProjectile = true;
                        projectiles.add(bossProj);
                        scene.time.delayedCall(3000, () => { if (bossProj.active) bossProj.destroy(); });
                    });
                }
                boss.isAttacking = false;
            });
        }

        function bossGroundSlam(scene) {
            scene.tweens.add({
                targets: boss, y: boss.y - 50, duration: 600, ease: 'Power2', yoyo: true,
                onComplete: () => {
                    scene.cameras.main.shake(300, 0.01);
                    for (let r = 80; r <= 300; r += 80) {
                        scene.time.delayedCall((r - 80) * 2, () => {
                            const sw = scene.add.circle(boss.x, boss.y, r, 0xff0051, 0).setStrokeStyle(6, 0xff3366, 0.7);
                            scene.physics.add.existing(sw);
                            const dist = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
                            if (dist < r + 30 && dist > r - 30 && !isDodging) hitPlayer(scene, 12);
                            scene.tweens.add({ targets: sw, alpha: 0, duration: 400, onComplete: () => sw.destroy() });
                        });
                    }
                    boss.isAttacking = false;
                }
            });
        }

        function hitBoss(scene, damage) {
            bossHealth = Math.max(0, bossHealth - damage); damageDealt += damage;
            scene.tweens.add({ targets: boss, alpha: 0.5, duration: 80, yoyo: true });
            createHitParticles(scene, boss.x, boss.y, 0xff0051, 12);
            scene.cameras.main.shake(120, 0.003);
        }

        function hitPlayer(scene, damage) {
            playerHealth = Math.max(0, playerHealth - damage);
            scene.tweens.add({ targets: player, alpha: 0.3, duration: 100, yoyo: true });
            createHitParticles(scene, player.x, player.y, 0xff6666, 8);
        }

        function hitPlayerProjectile(playerObj, proj) {
            if (isDodging || !proj.isBossProjectile) return;
            hitPlayer(game.scene.scenes[0], 8);
            proj.destroy();
        }

        function createHitParticles(scene, x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const p = scene.add.circle(x, y, 5, color);
                const angle = (Math.PI * 2 * i) / count;
                scene.tweens.add({ targets: p, x: x + Math.cos(angle) * 50, y: y + Math.sin(angle) * 50, alpha: 0, duration: 500, onComplete: () => p.destroy() });
            }
        }

        function updateHealthBars() {
            playerHealthText.width = 400 * (playerHealth / 100);
            bossHealthText.width = 380 * (bossHealth / 500);
            if (playerHealth < 30) playerHealthText.fillColor = 0xff0000;
            else if (playerHealth < 60) playerHealthText.fillColor = 0xffaa00;
            else playerHealthText.fillColor = 0x00ff88;
        }

        function updateStaminaBar() { staminaText.width = 280 * (playerStamina / 100); }

        function handleGameOver(scene) {
            scene.physics.pause();
            const isVictory = bossHealth <= 0;
            const msg = isVictory ? '‚ú® VICTOIRE! ‚ú®' : 'üíÄ D√âFAITE üíÄ';
            const color = isVictory ? '#00ff88' : '#ff3355';
            
            const txt = scene.add.text(500, 300, msg, { fontSize: '72px', fill: color, fontStyle: 'bold', stroke: '#000', strokeThickness: 8 }).setOrigin(0.5);
            scene.tweens.add({ targets: txt, scale: 1.15, duration: 600, yoyo: true, repeat: -1 });

            if (isVictory) {
                const stats = `D√©g√¢ts: ${damageDealt} | Esquives: ${dodgesPerformed}`;
                scene.add.text(500, 380, stats, { fontSize: '18px', fill: '#aaa', backgroundColor: '#00000099', padding: { x: 20, y: 10 }}).setOrigin(0.5);
            }

            const restart = scene.add.text(500, 450, 'Cliquer pour recommencer', { fontSize: '22px', fill: '#fff', backgroundColor: '#00000099', padding: { x: 25, y: 12 }}).setOrigin(0.5);
            
            scene.input.once('pointerdown', resetGame);
            scene.input.keyboard.once('keydown', resetGame);
            
            function resetGame() {
                scene.scene.restart();
                playerHealth = 100; bossHealth = 500; playerStamina = 100;
                damageDealt = 0; dodgesPerformed = 0; bossNextAttackTime = 0;
            }
        }

        window.addEventListener('load', () => { game = new Phaser.Game(config); });
    </script>
</body>
</html>
