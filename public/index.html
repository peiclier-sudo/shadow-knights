<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Shadow Knights - Boss Rush SMOOTH</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        * { margin: 0; padding: 0; overflow: hidden; }
        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a1a 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        #game-container { 
            box-shadow: 0 0 60px rgba(0,212,255,0.4);
            max-width: 100vw;
            max-height: 100vh;
        }
        /* Message de rotation pour mobile portrait */
        #rotate-message {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            font-size: 24px;
            text-align: center;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 9999;
        }
        @media (max-width: 900px) and (orientation: portrait) {
            #game-container { display: none; }
            #rotate-message { display: flex; }
        }
    </style>
</head>
<body>
    <div id="rotate-message">
        <div style="font-size: 60px; margin-bottom: 20px;">ðŸ“± â†»</div>
        <div>Tournez votre appareil</div>
        <div style="font-size: 16px; margin-top: 10px; opacity: 0.7;">Mode paysage requis</div>
    </div>
    <div id="game-container"></div>
    <script>
        const config = {
            type: Phaser.AUTO,
            width: 1000,
            height: 700,
            parent: 'game-container',
            backgroundColor: '#0f0f1e',
            physics: { default: 'arcade', arcade: { gravity: { y: 0 }}},
            scene: { create, update },
            scale: { 
                mode: Phaser.Scale.FIT, 
                autoCenter: Phaser.Scale.CENTER_BOTH,
                width: 1000,
                height: 700
            }
        };

        let game, player, boss, projectiles;
        let cursors, keys, playerHealth = 100, bossHealth = 500, playerStamina = 100;
        let isDodging = false, canDodge = true, canAttack = true;
        let playerHealthBar, bossHealthBar, staminaBar, playerHealthText, bossHealthText, staminaText;
        let virtualJoystick, dodgeButton;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let bossNextAttackTime = 0, damageDealt = 0, dodgesPerformed = 0;
        let aimAngle = 0, isAiming = false, aimIndicator;

        function create() {
            // Grille
            const g = this.add.graphics();
            g.lineStyle(1, 0x1a1a2e, 0.4);
            for (let i = 0; i < 1000; i += 50) g.lineBetween(i, 0, i, 700);
            for (let i = 0; i < 700; i += 50) g.lineBetween(0, i, 1000, i);

            // Joueur
            player = this.add.circle(150, 350, 22, 0x00d4ff);
            this.physics.add.existing(player);
            player.body.setCollideWorldBounds(true);
            player.direction = 1;
            player.glow = this.add.circle(150, 350, 35, 0x00d4ff, 0.3);
            
            // Indicateur de visÃ©e (ligne pointillÃ©e)
            aimIndicator = this.add.graphics();
            aimIndicator.setDepth(10);

            // Boss
            boss = this.add.container(850, 350);
            boss.add([
                this.add.rectangle(0, 0, 70, 100, 0xff0051),
                this.add.circle(0, -60, 30, 0xff0051)
            ]);
            this.physics.add.existing(boss);
            boss.body.setSize(70, 130);
            boss.body.setCollideWorldBounds(true);
            boss.body.immovable = true;
            boss.glow = this.add.circle(850, 350, 90, 0xff0051, 0.2);
            boss.isAttacking = false;

            projectiles = this.physics.add.group();
            this.physics.add.overlap(player, projectiles, hitPlayerProjectile, null, this);

            // ContrÃ´les
            cursors = this.input.keyboard.createCursorKeys();
            keys = {
                space: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE),
                shift: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT),
                Z: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Z),
                Q: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q),
                S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),
                D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)
            };
            
            // Desktop: Clic droit pour viser et tirer
            if (!isMobile) {
                this.input.on('pointerdown', (pointer) => {
                    if (pointer.rightButtonDown()) {
                        isAiming = true;
                        const dx = pointer.x - player.x;
                        const dy = pointer.y - player.y;
                        aimAngle = Math.atan2(dy, dx);
                    }
                });
                
                this.input.on('pointermove', (pointer) => {
                    if (isAiming && pointer.rightButtonDown()) {
                        const dx = pointer.x - player.x;
                        const dy = pointer.y - player.y;
                        aimAngle = Math.atan2(dy, dx);
                    }
                });
                
                this.input.on('pointerup', (pointer) => {
                    if (pointer.button === 2 && isAiming) {
                        // Tirer en relÃ¢chant le clic droit
                        if (canAttack && playerStamina >= 20) {
                            performRangedAttack(this);
                        }
                        isAiming = false;
                    }
                });
                
                // DÃ©sactiver le menu contextuel du clic droit
                this.input.mouse.disableContextMenu();
            }

            // UI
            this.add.text(20, 20, 'CHEVALIER', { fontSize: '20px', fill: '#00d4ff', fontStyle: 'bold' });
            playerHealthBar = this.add.rectangle(20, 60, 400, 28, 0x1a1a2e).setOrigin(0, 0.5).setStrokeStyle(3, 0x333355);
            playerHealthText = this.add.rectangle(20, 60, 400, 28, 0x00ff88).setOrigin(0, 0.5);
            
            this.add.text(20, 88, 'STAMINA', { fontSize: '14px', fill: '#ffaa00' });
            staminaBar = this.add.rectangle(20, 110, 280, 16, 0x1a1a2e).setOrigin(0, 0.5).setStrokeStyle(2, 0x333355);
            staminaText = this.add.rectangle(20, 110, 280, 16, 0xffaa00).setOrigin(0, 0.5);

            this.add.text(600, 20, 'SEIGNEUR DES OMBRES', { fontSize: '22px', fill: '#ff0051', fontStyle: 'bold' });
            bossHealthBar = this.add.rectangle(600, 65, 380, 30, 0x1a1a2e).setOrigin(0, 0.5).setStrokeStyle(3, 0x333355);
            bossHealthText = this.add.rectangle(600, 65, 380, 30, 0xff0051).setOrigin(0, 0.5);

            if (isMobile) createMobileControls(this);

            const instructions = isMobile ? 'Gauche: Bouger | Droite: Viser & Tirer | Coin: Dash' 
                : 'ZQSD/FlÃ¨ches: Bouger | CLIC DROIT: Viser & Tirer | ESPACE: MÃªlÃ©e | SHIFT: Dash';
            this.add.text(500, 680, instructions, { fontSize: '12px', fill: '#aaa', backgroundColor: '#00000099', padding: { x: 15, y: 8 }}).setOrigin(0.5);
        }

        function createMobileControls(scene) {
            // Debug overlay
            const debugText = scene.add.text(500, 650, 'DEBUG: PrÃªt', { 
                fontSize: '14px', 
                fill: '#ffff00', 
                backgroundColor: '#000000dd', 
                padding: { x: 10, y: 5 }
            }).setOrigin(0.5).setDepth(2000);
            
            // Variables simples
            let leftTouch = null;  // { pointerId, joy: {base, thumb} }
            let rightTouch = null; // { pointerId, joy: {base, thumb} }
            
            // Zones visuelles plus visibles
            const leftZone = scene.add.rectangle(250, 350, 500, 700, 0x0066ff, 0.15);
            leftZone.setDepth(0);
            scene.add.text(250, 60, 'â¬…ï¸ BOUGER', { fontSize: '20px', fill: '#00d4ff', fontStyle: 'bold' }).setOrigin(0.5).setDepth(1000);
            
            const rightZone = scene.add.rectangle(750, 350, 500, 700, 0xff0033, 0.15);
            rightZone.setDepth(0);
            scene.add.text(750, 60, 'TIRER âž¡ï¸', { fontSize: '20px', fill: '#ff6666', fontStyle: 'bold' }).setOrigin(0.5).setDepth(1000);
            
            // Ligne de sÃ©paration
            const line = scene.add.rectangle(500, 350, 4, 700, 0xffffff, 0.3);
            line.setDepth(50);
            
            // Activer multi-touch Phaser
            scene.input.addPointer(3);
            
            // POINTERDOWN
            scene.input.on('pointerdown', (pointer) => {
                const side = pointer.x < 500 ? 'LEFT' : 'RIGHT';
                debugText.setText(`DOWN: ${side} (ID:${pointer.id})`);
                console.log('POINTERDOWN:', side, 'ID:', pointer.id, 'X:', pointer.x);
                
                if (side === 'LEFT' && !leftTouch) {
                    leftTouch = {
                        pointerId: pointer.id,
                        startX: pointer.x,
                        startY: pointer.y,
                        joy: {
                            base: scene.add.circle(pointer.x, pointer.y, 60, 0x0033aa, 0.7),
                            thumb: scene.add.circle(pointer.x, pointer.y, 30, 0x00d4ff, 1)
                        }
                    };
                    leftTouch.joy.base.setDepth(300);
                    leftTouch.joy.thumb.setDepth(301);
                    console.log('LEFT JOY CREATED');
                }
                
                if (side === 'RIGHT' && !rightTouch) {
                    rightTouch = {
                        pointerId: pointer.id,
                        startX: pointer.x,
                        startY: pointer.y,
                        joy: {
                            base: scene.add.circle(pointer.x, pointer.y, 60, 0xaa3300, 0.7),
                            thumb: scene.add.circle(pointer.x, pointer.y, 30, 0xff6666, 1)
                        }
                    };
                    rightTouch.joy.base.setDepth(300);
                    rightTouch.joy.thumb.setDepth(301);
                    console.log('RIGHT JOY CREATED');
                }
            });
            
            // POINTERMOVE
            scene.input.on('pointermove', (pointer) => {
                if (!pointer.isDown) return;
                
                // MOUVEMENT GAUCHE
                if (leftTouch && pointer.id === leftTouch.pointerId) {
                    const dx = pointer.x - leftTouch.startX;
                    const dy = pointer.y - leftTouch.startY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const maxDist = 60;
                    
                    if (dist < maxDist) {
                        leftTouch.joy.thumb.x = leftTouch.startX + dx;
                        leftTouch.joy.thumb.y = leftTouch.startY + dy;
                        virtualJoystick.deltaX = dx / maxDist;
                        virtualJoystick.deltaY = dy / maxDist;
                    } else {
                        const angle = Math.atan2(dy, dx);
                        leftTouch.joy.thumb.x = leftTouch.startX + Math.cos(angle) * maxDist;
                        leftTouch.joy.thumb.y = leftTouch.startY + Math.sin(angle) * maxDist;
                        virtualJoystick.deltaX = Math.cos(angle);
                        virtualJoystick.deltaY = Math.sin(angle);
                    }
                    virtualJoystick.active = true;
                    debugText.setText(`MOVE LEFT (${virtualJoystick.deltaX.toFixed(2)}, ${virtualJoystick.deltaY.toFixed(2)})`);
                }
                
                // VISÃ‰E DROITE
                if (rightTouch && pointer.id === rightTouch.pointerId) {
                    const dx = pointer.x - rightTouch.startX;
                    const dy = pointer.y - rightTouch.startY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const maxDist = 60;
                    
                    if (dist < maxDist) {
                        rightTouch.joy.thumb.x = rightTouch.startX + dx;
                        rightTouch.joy.thumb.y = rightTouch.startY + dy;
                    } else {
                        const angle = Math.atan2(dy, dx);
                        rightTouch.joy.thumb.x = rightTouch.startX + Math.cos(angle) * maxDist;
                        rightTouch.joy.thumb.y = rightTouch.startY + Math.sin(angle) * maxDist;
                    }
                    
                    aimAngle = Math.atan2(dy, dx);
                    isAiming = dist > 15;
                    debugText.setText(`AIM RIGHT (angle: ${(aimAngle * 180 / Math.PI).toFixed(0)}Â°)`);
                }
            });
            
            // POINTERUP
            scene.input.on('pointerup', (pointer) => {
                console.log('POINTERUP ID:', pointer.id);
                
                // RELÃ‚CHE GAUCHE
                if (leftTouch && pointer.id === leftTouch.pointerId) {
                    leftTouch.joy.base.destroy();
                    leftTouch.joy.thumb.destroy();
                    leftTouch = null;
                    virtualJoystick.active = false;
                    virtualJoystick.deltaX = 0;
                    virtualJoystick.deltaY = 0;
                    debugText.setText('LEFT UP');
                    console.log('LEFT JOY DESTROYED');
                }
                
                // RELÃ‚CHE DROITE = TIR
                if (rightTouch && pointer.id === rightTouch.pointerId) {
                    if (isAiming && canAttack && playerStamina >= 20) {
                        performRangedAttack(scene);
                        debugText.setText('FIRED!');
                    }
                    
                    rightTouch.joy.base.destroy();
                    rightTouch.joy.thumb.destroy();
                    rightTouch = null;
                    isAiming = false;
                    debugText.setText('RIGHT UP');
                    console.log('RIGHT JOY DESTROYED');
                }
            });
            
            // Init
            virtualJoystick = { active: false, deltaX: 0, deltaY: 0 };
            
            // Bouton DASH DIRECTIONNEL (drag & drop)
            const dashBase = scene.add.circle(950, 150, 55, 0x1a2a3e, 0.8).setDepth(1000);
            dashBase.setStrokeStyle(6, 0x00d4ff);
            
            const dashThumb = scene.add.circle(950, 150, 28, 0x00d4ff, 1).setDepth(1001);
            const dashText = scene.add.text(950, 150, 'âš¡', { fontSize: '24px', fill: '#fff' }).setOrigin(0.5).setDepth(1002);
            
            let dashActive = false;
            let dashStartX = 950, dashStartY = 150;
            let dashAngle = 0;
            
            dashBase.setInteractive();
            
            dashBase.on('pointerdown', (pointer) => {
                if (pointer.x > 800) { // Seulement si on tap dans la zone dash
                    dashActive = true;
                    dashStartX = 950;
                    dashStartY = 150;
                    dashBase.setStrokeStyle(8, 0x00ffff); // Highlight
                }
            });
            
            scene.input.on('pointermove', (pointer) => {
                if (dashActive && pointer.isDown && pointer.x > 800) {
                    const dx = pointer.x - dashStartX;
                    const dy = pointer.y - dashStartY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const maxDist = 55;
                    
                    if (dist < maxDist) {
                        dashThumb.x = dashStartX + dx;
                        dashThumb.y = dashStartY + dy;
                    } else {
                        const angle = Math.atan2(dy, dx);
                        dashThumb.x = dashStartX + Math.cos(angle) * maxDist;
                        dashThumb.y = dashStartY + Math.sin(angle) * maxDist;
                    }
                    
                    dashAngle = Math.atan2(dy, dx);
                    
                    // Indicateur directionnel
                    if (dist > 10) {
                        dashText.setText('â†’');
                        dashText.setRotation(dashAngle);
                    }
                }
            });
            
            scene.input.on('pointerup', (pointer) => {
                if (dashActive && pointer.x > 800) {
                    dashActive = false;
                    dashBase.setStrokeStyle(6, 0x00d4ff); // Reset
                    
                    // Reset visuel
                    dashThumb.x = 950;
                    dashThumb.y = 150;
                    dashText.setText('âš¡');
                    dashText.setRotation(0);
                    
                    // DASH DIRECTIONNEL !
                    if (canDodge && playerStamina >= 25) {
                        performDirectionalDodge(scene, dashAngle);
                        debugText.setText('DASH DIRECTIONNEL!');
                    }
                }
            });
        }

        function update(time) {
            if (playerHealth <= 0 || bossHealth <= 0) { handleGameOver(this); return; }

            let vx = 0, vy = 0;
            const speed = isDodging ? 500 : 220;
            if (cursors.left.isDown || keys.Q.isDown) { vx = -speed; player.direction = -1; }
            else if (cursors.right.isDown || keys.D.isDown) { vx = speed; player.direction = 1; }
            if (cursors.up.isDown || keys.Z.isDown) vy = -speed;
            else if (cursors.down.isDown || keys.S.isDown) vy = speed;

            if (virtualJoystick && virtualJoystick.active) {
                vx = virtualJoystick.deltaX * speed; vy = virtualJoystick.deltaY * speed;
                if (vx !== 0) player.direction = vx > 0 ? 1 : -1;
            }
            player.body.setVelocity(vx, vy);
            player.glow.x = player.x; player.glow.y = player.y;
            
            // Indicateur de visÃ©e
            aimIndicator.clear();
            if (isAiming) {
                const aimLength = 100;
                const targetX = player.x + Math.cos(aimAngle) * aimLength;
                const targetY = player.y + Math.sin(aimAngle) * aimLength;
                
                // Ligne pointillÃ©e
                aimIndicator.lineStyle(3, 0xff6666, 0.8);
                for (let i = 0; i < aimLength; i += 10) {
                    const x1 = player.x + Math.cos(aimAngle) * i;
                    const y1 = player.y + Math.sin(aimAngle) * i;
                    const x2 = player.x + Math.cos(aimAngle) * (i + 5);
                    const y2 = player.y + Math.sin(aimAngle) * (i + 5);
                    aimIndicator.lineBetween(x1, y1, x2, y2);
                }
                
                // Cercle cible
                aimIndicator.lineStyle(2, 0xff3333, 0.9);
                aimIndicator.strokeCircle(targetX, targetY, 8);
            }

            if (Phaser.Input.Keyboard.JustDown(keys.space) && canAttack && !isDodging && playerStamina >= 15) performMeleeAttack(this);
            if (Phaser.Input.Keyboard.JustDown(keys.shift) && canDodge && playerStamina >= 25) performDodge(this);

            if (playerStamina < 100 && !isDodging) {
                playerStamina = Math.min(100, playerStamina + 0.4);
                updateStaminaBar();
            }

            if (time > bossNextAttackTime && !boss.isAttacking) {
                bossNextAttackTime = time + Phaser.Math.Between(2500, 4000);
                executeBossAttack(this);
            }

            boss.glow.x = boss.x; boss.glow.y = boss.y;
            updateHealthBars();
        }

        function performMeleeAttack(scene) {
            canAttack = false; playerStamina -= 15;
            scene.tweens.add({ targets: player, x: player.x + player.direction * 80, duration: 120, ease: 'Power2', yoyo: true });
            const slash = scene.add.rectangle(player.x + player.direction * 50, player.y, 40, 15, 0xffff00, 0.9);
            scene.tweens.add({ targets: slash, alpha: 0, scaleX: 1.5, duration: 150, onComplete: () => slash.destroy() });
            const dist = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
            if (dist < 120) hitBoss(scene, 12);
            scene.time.delayedCall(350, () => canAttack = true);
        }

        function performRangedAttack(scene) {
            canAttack = false; playerStamina -= 20;
            
            // Calculer la direction du projectile selon aimAngle
            const projSpeed = 500;
            const startX = player.x + Math.cos(aimAngle) * 30;
            const startY = player.y + Math.sin(aimAngle) * 30;
            
            // CrÃ©er le projectile avec physics
            const proj = scene.add.circle(startX, startY, 8, 0x66ffff);
            scene.physics.add.existing(proj);
            
            // CRITICAL: DÃ©finir le body comme circle et activer
            proj.body.setCircle(8);
            proj.body.enable = true;
            proj.body.allowGravity = false;
            
            // DÃ©finir la vÃ©locitÃ©
            const vx = Math.cos(aimAngle) * projSpeed;
            const vy = Math.sin(aimAngle) * projSpeed;
            proj.body.setVelocity(vx, vy);
            
            proj.damage = 18;
            projectiles.add(proj);
            
            console.log('PROJECTILE FIRED:', 'vx:', vx, 'vy:', vy, 'angle:', aimAngle);

            // Trail effect avec timer
            let trailCount = 0;
            const trailInterval = scene.time.addEvent({
                delay: 40,
                callback: () => {
                    if (proj.active && trailCount < 25) {
                        const trail = scene.add.circle(proj.x, proj.y, 6, 0x66ffff, 0.5);
                        scene.tweens.add({ 
                            targets: trail, 
                            alpha: 0, 
                            scale: 0.5, 
                            duration: 300, 
                            onComplete: () => trail.destroy() 
                        });
                        trailCount++;
                    } else {
                        trailInterval.remove();
                    }
                },
                loop: true
            });

            // Collision avec le boss
            scene.physics.add.overlap(proj, boss, () => { 
                if (proj.active) {
                    hitBoss(scene, proj.damage); 
                    // Impact effect
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI * 2 * i) / 6;
                        const spark = scene.add.circle(proj.x, proj.y, 4, 0x66ffff);
                        scene.tweens.add({
                            targets: spark,
                            x: proj.x + Math.cos(angle) * 30,
                            y: proj.y + Math.sin(angle) * 30,
                            alpha: 0,
                            duration: 300,
                            onComplete: () => spark.destroy()
                        });
                    }
                    trailInterval.remove();
                    proj.destroy();
                }
            });

            // Auto-destroy aprÃ¨s 2.5s
            scene.time.delayedCall(2500, () => { 
                if (proj.active) {
                    trailInterval.remove();
                    proj.destroy(); 
                }
            });
            
            scene.time.delayedCall(400, () => canAttack = true);
        }

        function performDodge(scene) {
            isDodging = true; canDodge = false; playerStamina -= 25; dodgesPerformed++;
            player.alpha = 0.3;

            const dashDist = 150;
            let dashX = 0, dashY = 0;
            if (cursors.left.isDown || keys.Q.isDown) dashX = -dashDist;
            else if (cursors.right.isDown || keys.D.isDown) dashX = dashDist;
            else dashX = player.direction * dashDist;
            if (cursors.up.isDown || keys.Z.isDown) dashY = -dashDist;
            else if (cursors.down.isDown || keys.S.isDown) dashY = dashDist;

            scene.tweens.add({ targets: player, x: player.x + dashX, y: player.y + dashY, duration: 250, ease: 'Power3', onComplete: () => { isDodging = false; player.alpha = 1; }});

            for (let i = 0; i < 6; i++) {
                scene.time.delayedCall(i * 40, () => {
                    const trail = scene.add.circle(player.x, player.y, 22, 0x00d4ff, 0.25);
                    scene.tweens.add({ targets: trail, alpha: 0, scale: 0.5, duration: 250, onComplete: () => trail.destroy() });
                });
            }

            scene.time.delayedCall(700, () => canDodge = true);
        }

        function performDirectionalDodge(scene, angle) {
            isDodging = true; canDodge = false; playerStamina -= 25; dodgesPerformed++;
            player.alpha = 0.3;

            const dashDist = 150;
            const dashX = Math.cos(angle) * dashDist;
            const dashY = Math.sin(angle) * dashDist;

            scene.tweens.add({ 
                targets: player, 
                x: player.x + dashX, 
                y: player.y + dashY, 
                duration: 250, 
                ease: 'Power3', 
                onComplete: () => { isDodging = false; player.alpha = 1; }
            });

            // Trail effect directionnel
            for (let i = 0; i < 6; i++) {
                scene.time.delayedCall(i * 40, () => {
                    const trail = scene.add.circle(player.x, player.y, 22, 0x00d4ff, 0.25);
                    scene.tweens.add({ targets: trail, alpha: 0, scale: 0.5, duration: 250, onComplete: () => trail.destroy() });
                });
            }

            scene.time.delayedCall(700, () => canDodge = true);
        }

        function executeBossAttack(scene) {
            boss.isAttacking = true;
            const pattern = Phaser.Math.Between(0, 2);
            if (pattern === 0) bossSlashCombo(scene);
            else if (pattern === 1) bossProjectileBarrage(scene);
            else bossGroundSlam(scene);
        }

        function bossSlashCombo(scene) {
            const warning = scene.add.rectangle(boss.x - 120, boss.y, 180, 150, 0xff0051, 0.15).setStrokeStyle(3, 0xff0051, 0.6);
            scene.tweens.add({ targets: warning, alpha: 0.4, duration: 800, yoyo: true, repeat: 1 });

            scene.time.delayedCall(1200, () => {
                warning.destroy();
                const slashZone = scene.add.rectangle(boss.x - 120, boss.y, 180, 150, 0xff6666, 0.6);
                scene.physics.add.existing(slashZone);
                scene.physics.add.overlap(player, slashZone, () => { if (!isDodging) hitPlayer(scene, 15); });
                scene.tweens.add({ targets: slashZone, alpha: 0, duration: 200, onComplete: () => { slashZone.destroy(); boss.isAttacking = false; }});
                scene.cameras.main.shake(150, 0.004);
            });
        }

        function bossProjectileBarrage(scene) {
            const warning = scene.add.circle(boss.x, boss.y, 50, 0xff0051, 0.2).setStrokeStyle(4, 0xff0051, 0.7);
            scene.tweens.add({ targets: warning, radius: 80, alpha: 0, duration: 1000, onComplete: () => warning.destroy() });

            scene.time.delayedCall(1000, () => {
                for (let i = 0; i < 8; i++) {
                    scene.time.delayedCall(i * 150, () => {
                        const angle = (Math.PI * 2 * i / 8);
                        const bossProj = scene.add.circle(boss.x, boss.y, 10, 0xff3366);
                        scene.physics.add.existing(bossProj);
                        bossProj.body.setVelocity(Math.cos(angle) * 280, Math.sin(angle) * 280);
                        bossProj.isBossProjectile = true;
                        projectiles.add(bossProj);
                        scene.time.delayedCall(3000, () => { if (bossProj.active) bossProj.destroy(); });
                    });
                }
                boss.isAttacking = false;
            });
        }

        function bossGroundSlam(scene) {
            scene.tweens.add({
                targets: boss, y: boss.y - 50, duration: 600, ease: 'Power2', yoyo: true,
                onComplete: () => {
                    scene.cameras.main.shake(300, 0.01);
                    for (let r = 80; r <= 300; r += 80) {
                        scene.time.delayedCall((r - 80) * 2, () => {
                            const sw = scene.add.circle(boss.x, boss.y, r, 0xff0051, 0).setStrokeStyle(6, 0xff3366, 0.7);
                            scene.physics.add.existing(sw);
                            const dist = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
                            if (dist < r + 30 && dist > r - 30 && !isDodging) hitPlayer(scene, 12);
                            scene.tweens.add({ targets: sw, alpha: 0, duration: 400, onComplete: () => sw.destroy() });
                        });
                    }
                    boss.isAttacking = false;
                }
            });
        }

        function hitBoss(scene, damage) {
            bossHealth = Math.max(0, bossHealth - damage); damageDealt += damage;
            scene.tweens.add({ targets: boss, alpha: 0.5, duration: 80, yoyo: true });
            createHitParticles(scene, boss.x, boss.y, 0xff0051, 12);
            scene.cameras.main.shake(120, 0.003);
        }

        function hitPlayer(scene, damage) {
            playerHealth = Math.max(0, playerHealth - damage);
            scene.tweens.add({ targets: player, alpha: 0.3, duration: 100, yoyo: true });
            createHitParticles(scene, player.x, player.y, 0xff6666, 8);
        }

        function hitPlayerProjectile(playerObj, proj) {
            if (isDodging || !proj.isBossProjectile) return;
            hitPlayer(game.scene.scenes[0], 8);
            proj.destroy();
        }

        function createHitParticles(scene, x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const p = scene.add.circle(x, y, 5, color);
                const angle = (Math.PI * 2 * i) / count;
                scene.tweens.add({ targets: p, x: x + Math.cos(angle) * 50, y: y + Math.sin(angle) * 50, alpha: 0, duration: 500, onComplete: () => p.destroy() });
            }
        }

        function updateHealthBars() {
            playerHealthText.width = 400 * (playerHealth / 100);
            bossHealthText.width = 380 * (bossHealth / 500);
            if (playerHealth < 30) playerHealthText.fillColor = 0xff0000;
            else if (playerHealth < 60) playerHealthText.fillColor = 0xffaa00;
            else playerHealthText.fillColor = 0x00ff88;
        }

        function updateStaminaBar() { staminaText.width = 280 * (playerStamina / 100); }

        function handleGameOver(scene) {
            scene.physics.pause();
            const isVictory = bossHealth <= 0;
            const msg = isVictory ? 'âœ¨ VICTOIRE! âœ¨' : 'ðŸ’€ DÃ‰FAITE ðŸ’€';
            const color = isVictory ? '#00ff88' : '#ff3355';
            
            const txt = scene.add.text(500, 300, msg, { fontSize: '72px', fill: color, fontStyle: 'bold', stroke: '#000', strokeThickness: 8 }).setOrigin(0.5);
            scene.tweens.add({ targets: txt, scale: 1.15, duration: 600, yoyo: true, repeat: -1 });

            if (isVictory) {
                const stats = `DÃ©gÃ¢ts: ${damageDealt} | Esquives: ${dodgesPerformed}`;
                scene.add.text(500, 380, stats, { fontSize: '18px', fill: '#aaa', backgroundColor: '#00000099', padding: { x: 20, y: 10 }}).setOrigin(0.5);
            }

            const restart = scene.add.text(500, 450, 'Cliquer pour recommencer', { fontSize: '22px', fill: '#fff', backgroundColor: '#00000099', padding: { x: 25, y: 12 }}).setOrigin(0.5);
            
            scene.input.once('pointerdown', resetGame);
            scene.input.keyboard.once('keydown', resetGame);
            
            function resetGame() {
                scene.scene.restart();
                playerHealth = 100; bossHealth = 500; playerStamina = 100;
                damageDealt = 0; dodgesPerformed = 0; bossNextAttackTime = 0;
            }
        }

        window.addEventListener('load', () => { game = new Phaser.Game(config); });
    </script>
</body>
</html>
