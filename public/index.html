<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SHADOW KNIGHTS - ULTRA EDITION</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            background: #000;
        }
        #game-container { 
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
        }
        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            object-fit: contain;
            image-rendering: crisp-edges; /* For sharpness */
            image-rendering: pixelated; /* Alternative for sharpness */
        }
        @media (max-width: 900px) and (orientation: portrait) {
            body::before {
                content: "ðŸ“± ROTATE";
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: #00d4ff;
                font-size: 32px;
                font-weight: bold;
                text-shadow: 0 0 20px #00d4ff;
                z-index: 9999;
            }
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
        // Configuration with MAXIMUM QUALITY settings
        const config = {
            type: Phaser.WEBGL,
            parent: 'game-container',
            backgroundColor: '#0a0a14',
            physics: { 
                default: 'arcade', 
                arcade: { 
                    gravity: { y: 0 },
                    fps: 120, // Higher physics FPS for smoother movement
                    timeScale: 1
                }
            },
            scene: { create, update },
            scale: { 
                mode: Phaser.Scale.RESIZE,
                autoCenter: Phaser.Scale.CENTER_BOTH,
                width: '100%',
                height: '100%'
            },
            render: {
                antialias: false, // CHANGED: false for sharper edges
                pixelArt: true,    // CHANGED: true for crisp pixel-perfect rendering
                roundPixels: true, // CHANGED: prevents blurry sub-pixel rendering
                powerPreference: 'high-performance',
                transparent: false,
                clearBeforeRender: true,
                premultipliedAlpha: false,
                preserveDrawingBuffer: false,
                failIfMajorPerformanceCaveat: false
            },
            fps: {
                target: 120, // CHANGED: Higher FPS target
                forceSetTimeOut: false,
                deltaHistory: 10,
                panicMax: 120
            }
        };

        // BOSS DATA with enhanced colors
        const BOSSES = {
            1: { name: 'SENTINEL', hp: 400, color: 0xff0051, glowColor: 0xff3366, secondaryColor: 0x990033 },
            2: { name: 'GUNNER', hp: 500, color: 0xff6600, glowColor: 0xff8833, secondaryColor: 0xcc4400 },
            3: { name: 'DASHER', hp: 600, color: 0xcc00ff, glowColor: 0xdd33ff, secondaryColor: 0x9900cc }
        };
        
        let currentBossId = parseInt(localStorage.getItem('currentBoss')) || 1;
        let unlockedBosses = parseInt(localStorage.getItem('unlockedBosses')) || 1;

        let game, player, boss;
        let playerHealth = 100, bossHealth = BOSSES[currentBossId].hp, playerStamina = 100;
        let isDodging = false, canDodge = true, canAttack = true;
        let playerHealthBar, bossHealthBar, staminaBar, playerHealthText, bossHealthText, staminaText;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let bossNextAttackTime = 0;
        
        // Dash variables
        let isDashing = false;
        let dashDirection = { x: 0, y: 0 };
        let dashTimer = 0;
        const DASH_DURATION = 200; // ms
        const DASH_SPEED = 1000; // CHANGED: +25% faster dash
        const DASH_COOLDOWN = 1000; // ms
        const DASH_STAMINA_COST = 40;
        let lastDashTime = 0;
        let isInvulnerable = false;
        
        // Charge attack variables
        let isCharging = false;
        let chargeStartTime = 0;
        const CHARGE_TIME = 1500; // ms for full charge
        const MAX_CHARGE_DAMAGE = 50;
        let chargeIndicator = null;
        let chargeLevel = 0;
        let isChargingAttack = false;
        
        // Mobile controls
        let moveJoy = { active: false, deltaX: 0, deltaY: 0 };
        let aimJoy = { active: false, angle: 0 };
        let projectiles = [];
        let bossProjectiles = [];
        
        // Desktop controls
        let leftMouseDown = false;
        let rightMouseDown = false;
        let mouseX = 0, mouseY = 0;
        let aimStartX = 0, aimStartY = 0;
        let aimIndicator = null;

        // Dash button for mobile
        let dashButton = null;
        
        // Stamina warning text
        let staminaWarning = null;
        
        // Visual effect containers
        let playerTrail = [];
        let bossTrail = [];
        let ambientParticles = [];

        function create() {
            const width = this.cameras.main.width;
            const height = this.cameras.main.height;
            
            // ENHANCED: Cinematic background with gradient
            const gradient = this.add.graphics();
            gradient.fillGradientStyle(0x0a0a14, 0x1a1a2e, 0x0a0a14, 0x1a1a2e, 1);
            gradient.fillRect(0, 0, width, height);
            
            // ENHANCED: Animated neon grid with glow
            let bossData = BOSSES[currentBossId];
            const grid = this.add.graphics();
            grid.lineStyle(2, bossData.color, 0.1);
            
            // Horizontal lines with glow effect
            for (let i = 0; i < height; i += 40) {
                // Main line
                grid.lineStyle(1.5, bossData.color, 0.15);
                grid.lineBetween(0, i, width, i);
                
                // Glow line (thicker, more transparent)
                grid.lineStyle(3, bossData.glowColor, 0.05);
                grid.lineBetween(0, i, width, i);
            }
            
            // Vertical lines
            for (let i = 0; i < width; i += 40) {
                grid.lineStyle(1.5, bossData.color, 0.15);
                grid.lineBetween(i, 0, i, height);
                
                grid.lineStyle(3, bossData.glowColor, 0.05);
                grid.lineBetween(i, 0, i, height);
            }
            
            // ENHANCED: Floating particles with more variety
            for (let i = 0; i < 80; i++) {
                const x = Phaser.Math.Between(0, width);
                const y = Phaser.Math.Between(0, height);
                const size = Phaser.Math.Between(1, 4);
                const colors = [0x00d4ff, bossData.color, bossData.glowColor, 0xffffff];
                const color = Phaser.Math.RND.pick(colors);
                
                // Main particle
                const particle = this.add.circle(x, y, size, color, 
                    color === 0xffffff ? 0.3 : 0.5);
                
                // Glow for larger particles
                if (size > 2) {
                    const glow = this.add.circle(x, y, size * 2, color, 0.1);
                    
                    this.tweens.add({
                        targets: [particle, glow],
                        y: y + Phaser.Math.Between(-50, 50),
                        x: x + Phaser.Math.Between(-20, 20),
                        alpha: 0.1,
                        duration: Phaser.Math.Between(3000, 6000),
                        yoyo: true,
                        repeat: -1,
                        ease: 'Sine.easeInOut',
                        delay: i * 50
                    });
                } else {
                    this.tweens.add({
                        targets: particle,
                        y: y + Phaser.Math.Between(-40, 40),
                        alpha: 0.1,
                        duration: Phaser.Math.Between(2000, 4000),
                        yoyo: true,
                        repeat: -1,
                        ease: 'Sine.easeInOut'
                    });
                }
                
                ambientParticles.push(particle);
            }

            // ENHANCED: Player with sharper design
            const playerX = width * 0.15;
            const playerY = height * 0.5;
            
            // Create player as a container for multiple shapes
            player = this.add.container(playerX, playerY);
            
            // Core (solid)
            const core = this.add.circle(0, 0, 18, 0x00d4ff);
            core.setStrokeStyle(2, 0xffffff);
            
            // Inner glow
            const innerGlow = this.add.circle(0, 0, 22, 0x00d4ff, 0.3);
            
            // Outer glow (pulsing)
            const outerGlow = this.add.circle(0, 0, 28, 0x00d4ff, 0.15);
            
            // Energy rings (for style)
            const ring1 = this.add.circle(0, 0, 24, 0x00d4ff, 0);
            ring1.setStrokeStyle(1.5, 0x88ddff, 0.6);
            
            const ring2 = this.add.circle(0, 0, 30, 0x00d4ff, 0);
            ring2.setStrokeStyle(1, 0x88ddff, 0.3);
            
            player.add([outerGlow, innerGlow, core, ring1, ring2]);
            
            // Store references for animations
            player.core = core;
            player.ring1 = ring1;
            player.ring2 = ring2;
            
            // Physics body on the container
            this.physics.add.existing(player);
            player.body.setCircle(18);
            player.body.setCollideWorldBounds(true);
            
            // ENHANCED: Player animations
            this.tweens.add({
                targets: ring1,
                scale: 1.2,
                alpha: 0.2,
                duration: 1000,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
            
            this.tweens.add({
                targets: ring2,
                scale: 1.4,
                alpha: 0.1,
                duration: 1500,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
            
            this.tweens.add({
                targets: core,
                scale: 1.05,
                duration: 800,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });

            // ENHANCED: Boss with sharper design
            bossData = BOSSES[currentBossId];
            const bossX = width * 0.85;
            const bossY = height * 0.5;
            
            boss = this.add.container(bossX, bossY);
            
            if (currentBossId === 1) {
                // Sentinel: Armored knight look
                const body = this.add.rectangle(0, 0, 70, 100, bossData.color);
                body.setStrokeStyle(3, bossData.glowColor);
                
                const head = this.add.circle(0, -60, 25, bossData.color);
                head.setStrokeStyle(2, bossData.glowColor);
                
                const visor = this.add.rectangle(0, -65, 20, 5, bossData.glowColor);
                
                const shoulderL = this.add.circle(-35, -30, 15, bossData.secondaryColor);
                const shoulderR = this.add.circle(35, -30, 15, bossData.secondaryColor);
                
                boss.add([body, head, visor, shoulderL, shoulderR]);
                
            } else if (currentBossId === 2) {
                // Gunner: Mechanical with guns
                const body = this.add.rectangle(0, 0, 60, 90, bossData.color);
                body.setStrokeStyle(3, bossData.glowColor);
                
                const head = this.add.rectangle(0, -50, 40, 30, bossData.color);
                head.setStrokeStyle(2, bossData.glowColor);
                
                const gunL = this.add.rectangle(-35, -10, 20, 10, bossData.secondaryColor);
                const gunR = this.add.rectangle(35, -10, 20, 10, bossData.secondaryColor);
                
                const barrelL = this.add.rectangle(-45, -10, 15, 5, bossData.glowColor);
                const barrelR = this.add.rectangle(45, -10, 15, 5, bossData.glowColor);
                
                boss.add([body, head, gunL, gunR, barrelL, barrelR]);
                
            } else if (currentBossId === 3) {
                // Dasher: Sleek assassin
                const body = this.add.ellipse(0, 0, 70, 100, bossData.color);
                body.setStrokeStyle(3, bossData.glowColor);
                
                const head = this.add.circle(0, -60, 25, bossData.color);
                head.setStrokeStyle(2, bossData.glowColor);
                
                const bladeL = this.add.triangle(-35, -20, -45, -30, -45, -10, bossData.glowColor);
                const bladeR = this.add.triangle(35, -20, 45, -30, 45, -10, bossData.glowColor);
                
                const visor = this.add.rectangle(0, -65, 30, 5, 0xff0000);
                
                boss.add([body, head, bladeL, bladeR, visor]);
            }
            
            this.physics.add.existing(boss);
            boss.body.setSize(70, 130);
            boss.body.setCollideWorldBounds(true);
            boss.body.immovable = true;
            
            // ENHANCED: Boss glow effects
            const bossGlow1 = this.add.circle(bossX, bossY, 90, bossData.glowColor, 0.2);
            const bossGlow2 = this.add.circle(bossX, bossY, 120, bossData.glowColor, 0.1);
            const bossGlow3 = this.add.circle(bossX, bossY, 150, bossData.color, 0.05);
            
            boss.glowEffects = [bossGlow1, bossGlow2, bossGlow3];
            
            this.tweens.add({
                targets: bossGlow1,
                scale: 1.1,
                alpha: 0.15,
                duration: 1200,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
            
            this.tweens.add({
                targets: bossGlow2,
                scale: 1.2,
                alpha: 0.08,
                duration: 1600,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
            
            this.tweens.add({
                targets: bossGlow3,
                scale: 1.15,
                alpha: 0.03,
                duration: 2000,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });

            // ENHANCED: UI with sharper text and neon effects
            const titleText = this.add.text(width * 0.5, height * 0.05, bossData.name, { 
                fontSize: Math.min(32, height * 0.045) + 'px', 
                fill: '#' + bossData.color.toString(16).padStart(6, '0'), 
                fontStyle: 'bold',
                stroke: '#fff',
                strokeThickness: 1,
                shadow: {
                    offsetX: 0,
                    offsetY: 0,
                    color: '#' + bossData.glowColor.toString(16).padStart(6, '0'),
                    blur: 10,
                    stroke: true,
                    fill: true
                }
            }).setOrigin(0.5);
            
            // Player health with gradient effect
            this.add.text(width * 0.02, height * 0.02, 'VOUS', { 
                fontSize: Math.min(18, height * 0.025) + 'px', 
                fill: '#00d4ff',
                fontStyle: 'bold',
                stroke: '#fff',
                strokeThickness: 1
            });
            
            playerHealthBar = this.add.rectangle(width * 0.02, height * 0.06, width * 0.3, height * 0.03, 0x1a1a2e)
                .setOrigin(0, 0.5).setStrokeStyle(2, 0x333355);
            playerHealthText = this.add.rectangle(width * 0.02, height * 0.06, width * 0.3, height * 0.03, 0x00ff88)
                .setOrigin(0, 0.5);
            
            // Stamina with gradient effect
            this.add.text(width * 0.02, height * 0.09, 'STAMINA', { 
                fontSize: Math.min(14, height * 0.02) + 'px', 
                fill: '#ffaa00',
                fontStyle: 'bold'
            });
            staminaBar = this.add.rectangle(width * 0.02, height * 0.12, width * 0.2, height * 0.02, 0x1a1a2e)
                .setOrigin(0, 0.5).setStrokeStyle(1, 0x333355);
            staminaText = this.add.rectangle(width * 0.02, height * 0.12, width * 0.2, height * 0.02, 0xffaa00)
                .setOrigin(0, 0.5);

            // Stamina warning
            staminaWarning = this.add.text(width * 0.5, height * 0.2, 'âš ï¸ INSUFFICIENT STAMINA âš ï¸', {
                fontSize: Math.min(20, height * 0.03) + 'px',
                fill: '#ff0000',
                stroke: '#000',
                strokeThickness: 4,
                backgroundColor: '#00000099',
                padding: { x: 20, y: 10 }
            }).setOrigin(0.5).setVisible(false);

            // Boss health
            this.add.text(width * 0.68, height * 0.07, 'BOSS', { 
                fontSize: Math.min(14, height * 0.02) + 'px', 
                fill: '#' + bossData.color.toString(16).padStart(6, '0'),
                fontStyle: 'bold'
            });
            bossHealthBar = this.add.rectangle(width * 0.68, height * 0.1, width * 0.3, height * 0.03, 0x1a1a2e)
                .setOrigin(0, 0.5).setStrokeStyle(2, 0x333355);
            bossHealthText = this.add.rectangle(width * 0.68, height * 0.1, width * 0.3, height * 0.03, bossData.color)
                .setOrigin(0, 0.5);

            // Charge indicator
            chargeIndicator = this.add.graphics();
            chargeIndicator.setDepth(1000);

            if (isMobile) {
                createMobileControls(this);
                createMobileDashButton(this);
            } else {
                createDesktopControls(this);
                this.input.keyboard.on('keydown-SPACE', () => {
                    performDash(this);
                });
            }

            // ENHANCED: Instructions with glow
            const instructions = isMobile ? 'â¬…ï¸ MOVE  |  âž¡ï¸ SHOOT  |  âš¡ DASH (40)' 
                : 'LEFT CLICK: MOVE  |  RIGHT CLICK: AIM/SHOOT  |  SPACE: DASH (40)  |  HOLD RIGHT: CHARGE';
            const instrText = this.add.text(width * 0.5, height * 0.95, instructions, { 
                fontSize: Math.min(13, height * 0.018) + 'px', 
                fill: '#fff', 
                backgroundColor: '#00000099', 
                padding: { x: 15, y: 8 },
                stroke: bossData.glowColor,
                strokeThickness: 0.5
            }).setOrigin(0.5);
        }

        // Mobile dash button (enhanced)
        function createMobileDashButton(scene) {
            const width = scene.cameras.main.width;
            const height = scene.cameras.main.height;
            
            dashButton = scene.add.container(width - 100, 100);
            
            // Outer glow
            const glow = scene.add.circle(0, 0, 45, 0x00d4ff, 0.2);
            
            // Background
            const bg = scene.add.circle(0, 0, 40, 0x00d4ff, 0.3);
            bg.setStrokeStyle(3, 0x88ddff);
            
            // Icon
            const icon = scene.add.text(0, -5, 'âš¡', { 
                fontSize: '36px', 
                fill: '#ffffff',
                fontStyle: 'bold',
                stroke: '#00d4ff',
                strokeThickness: 2
            }).setOrigin(0.5);
            
            // Cost
            const costText = scene.add.text(0, 25, '40', { 
                fontSize: '14px', 
                fill: '#ffaa00',
                fontStyle: 'bold',
                stroke: '#000',
                strokeThickness: 2
            }).setOrigin(0.5);
            
            // Cooldown overlay
            const cooldownOverlay = scene.add.circle(0, 0, 40, 0x000000, 0);
            cooldownOverlay.setStrokeStyle(2, 0xff0000);
            
            dashButton.add([glow, bg, icon, costText, cooldownOverlay]);
            dashButton.setSize(80, 80);
            dashButton.setInteractive({ useHandCursor: true });
            
            dashButton.on('pointerdown', () => {
                performDash(scene);
            });
            
            dashButton.cooldownOverlay = cooldownOverlay;
            dashButton.bg = bg;
            dashButton.icon = icon;
            
            // Pulsing animation
            scene.tweens.add({
                targets: glow,
                scale: 1.2,
                alpha: 0.1,
                duration: 1000,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
        }

        function createDesktopControls(scene) {
            aimIndicator = scene.add.graphics();
            aimIndicator.setDepth(500);
            
            scene.input.mouse.disableContextMenu();
            
            scene.input.on('pointerdown', (pointer) => {
                if (pointer.leftButtonDown()) {
                    leftMouseDown = true;
                    mouseX = pointer.x;
                    mouseY = pointer.y;
                }
                
                if (pointer.rightButtonDown()) {
                    rightMouseDown = true;
                    aimStartX = player.x;
                    aimStartY = player.y;
                    mouseX = pointer.x;
                    mouseY = pointer.y;
                    
                    if (!isDashing && playerStamina >= 30) {
                        startCharge(scene);
                    }
                }
            });
            
            scene.input.on('pointermove', (pointer) => {
                mouseX = pointer.x;
                mouseY = pointer.y;
                
                if (isChargingAttack) {
                    chargeLevel = Math.min(1, (Date.now() - chargeStartTime) / CHARGE_TIME);
                }
            });
            
            scene.input.on('pointerup', (pointer) => {
                if (pointer.button === 0) {
                    leftMouseDown = false;
                }
                
                if (pointer.button === 2) {
                    if (isChargingAttack) {
                        releaseCharge(scene);
                    } else if (rightMouseDown && canAttack && playerStamina >= 20) {
                        const angle = Math.atan2(mouseY - aimStartY, mouseX - aimStartX);
                        shootProjectile(scene, angle);
                    }
                    rightMouseDown = false;
                }
            });
        }

        // Start charging (enhanced visuals)
        function startCharge(scene) {
            if (player.body.velocity.x !== 0 || player.body.velocity.y !== 0) {
                return;
            }
            
            isChargingAttack = true;
            chargeStartTime = Date.now();
            chargeLevel = 0;
            
            // Charging particles
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const particle = scene.add.circle(
                    player.x + Math.cos(angle) * 30,
                    player.y + Math.sin(angle) * 30,
                    3,
                    0xffaa00,
                    0.8
                );
                
                scene.tweens.add({
                    targets: particle,
                    alpha: 0,
                    scale: 2,
                    x: player.x + Math.cos(angle) * 50,
                    y: player.y + Math.sin(angle) * 50,
                    duration: 500,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            }
            
            chargeIndicator.clear();
        }

        // Release charged attack (enhanced)
        function releaseCharge(scene) {
            if (!isChargingAttack) return;
            
            isChargingAttack = false;
            
            if (chargeLevel < 0.3) {
                const angle = Math.atan2(mouseY - aimStartY, mouseX - aimStartX);
                shootProjectile(scene, angle);
                return;
            }
            
            const damage = 18 + Math.floor(chargeLevel * MAX_CHARGE_DAMAGE);
            const angle = Math.atan2(mouseY - aimStartY, mouseX - aimStartX);
            
            playerStamina -= 30;
            
            // Epic charge release effect
            for (let i = 0; i < 20; i++) {
                const particleAngle = (i / 20) * Math.PI * 2;
                const particle = scene.add.circle(player.x, player.y, 5, 0xffaa00, 1);
                
                scene.tweens.add({
                    targets: particle,
                    x: player.x + Math.cos(particleAngle) * 100,
                    y: player.y + Math.sin(particleAngle) * 100,
                    alpha: 0,
                    scale: 0.5,
                    duration: 400,
                    ease: 'Power2',
                    onComplete: () => particle.destroy()
                });
            }
            
            for (let i = -1; i <= 1; i++) {
                const spreadAngle = angle + (i * 0.2);
                shootChargedProjectile(scene, spreadAngle, damage, chargeLevel);
            }
            
            scene.cameras.main.flash(150, 255, 255, 255, false);
            scene.cameras.main.shake(80 * chargeLevel, 0.004 * chargeLevel);
            
            chargeLevel = 0;
            chargeIndicator.clear();
        }

        // Charged projectile (enhanced)
        function shootChargedProjectile(scene, angle, damage, chargeLevel) {
            const speed = 900 + (chargeLevel * 400); // CHANGED: +20% faster
            const size = 10 + (chargeLevel * 18);
            const startX = player.x + Math.cos(angle) * 30;
            const startY = player.y + Math.sin(angle) * 30;
            
            // Epic flash
            const flash = scene.add.circle(startX, startY, 30 * chargeLevel + 25, 0xffffff, 1);
            scene.tweens.add({
                targets: flash,
                scale: 4,
                alpha: 0,
                duration: 200,
                onComplete: () => flash.destroy()
            });
            
            // Main projectile with core
            const projContainer = scene.add.container(startX, startY);
            
            const core = scene.add.circle(0, 0, size * 0.7, 0xffffff);
            const glow = scene.add.circle(0, 0, size, 0x66ffff, 0.8);
            const outerGlow = scene.add.circle(0, 0, size * 1.5, 0x66ffff, 0.3);
            
            projContainer.add([outerGlow, glow, core]);
            projContainer.setDepth(150);
            
            // Store for movement
            projContainer.vx = Math.cos(angle) * speed;
            projContainer.vy = Math.sin(angle) * speed;
            projContainer.damage = damage;
            
            projectiles.push(projContainer);
            
            // Enhanced trail
            let trailCount = 0;
            const trailInterval = setInterval(() => {
                if (!projContainer.scene || trailCount > 30) {
                    clearInterval(trailInterval);
                    return;
                }
                
                const trail = scene.add.circle(projContainer.x, projContainer.y, size * 0.5, 0x66ffff, 0.5);
                trail.setDepth(148);
                
                scene.tweens.add({
                    targets: trail,
                    alpha: 0,
                    scale: 0.3,
                    duration: 300,
                    ease: 'Power2',
                    onComplete: () => trail.destroy()
                });
                
                trailCount++;
            }, 30);
            
            scene.time.delayedCall(400, () => canAttack = true);
        }

        function createMobileControls(scene) {
            const width = scene.cameras.main.width;
            const height = scene.cameras.main.height;
            
            const leftZone = scene.add.rectangle(width * 0.25, height * 0.5, width * 0.5, height, 0x0066ff, 0.05);
            const rightZone = scene.add.rectangle(width * 0.75, height * 0.5, width * 0.5, height, 0xff6666, 0.05);
            
            scene.add.text(width * 0.25, height * 0.1, 'â¬…ï¸ MOVE', { 
                fontSize: Math.min(20, height * 0.025) + 'px', 
                fill: '#88ddff',
                fontStyle: 'bold',
                stroke: '#000',
                strokeThickness: 2
            }).setOrigin(0.5);
            
            scene.add.text(width * 0.75, height * 0.1, 'âž¡ï¸ SHOOT', { 
                fontSize: Math.min(20, height * 0.025) + 'px', 
                fill: '#ff8888',
                fontStyle: 'bold',
                stroke: '#000',
                strokeThickness: 2
            }).setOrigin(0.5);
            
            let leftTouch = null, rightTouch = null;
            
            scene.input.addPointer(3);
            
            scene.input.on('pointerdown', (pointer) => {
                if (pointer.x < width * 0.5 && !leftTouch) {
                    leftTouch = {
                        id: pointer.id,
                        startX: pointer.x,
                        startY: pointer.y,
                        base: scene.add.circle(pointer.x, pointer.y, 55, 0x0066ff, 0.4).setDepth(300),
                        thumb: scene.add.circle(pointer.x, pointer.y, 28, 0x88ddff, 1).setDepth(301),
                        glow: scene.add.circle(pointer.x, pointer.y, 70, 0x0066ff, 0.1).setDepth(299)
                    };
                    
                    // Add pulsing animation to base
                    scene.tweens.add({
                        targets: leftTouch.base,
                        scale: 1.1,
                        alpha: 0.3,
                        duration: 500,
                        yoyo: true,
                        repeat: -1
                    });
                }
                
                if (pointer.x >= width * 0.5 && !rightTouch) {
                    rightTouch = {
                        id: pointer.id,
                        startX: pointer.x,
                        startY: pointer.y,
                        base: scene.add.circle(pointer.x, pointer.y, 55, 0xaa3300, 0.4).setDepth(300),
                        thumb: scene.add.circle(pointer.x, pointer.y, 28, 0xff8888, 1).setDepth(301),
                        glow: scene.add.circle(pointer.x, pointer.y, 70, 0xaa3300, 0.1).setDepth(299)
                    };
                    
                    scene.tweens.add({
                        targets: rightTouch.base,
                        scale: 1.1,
                        alpha: 0.3,
                        duration: 500,
                        yoyo: true,
                        repeat: -1
                    });
                }
            });
            
            scene.input.on('pointermove', (pointer) => {
                if (!pointer.isDown) return;
                
                if (leftTouch && pointer.id === leftTouch.id) {
                    const dx = pointer.x - leftTouch.startX;
                    const dy = pointer.y - leftTouch.startY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const max = 55;
                    
                    if (dist < max) {
                        leftTouch.thumb.x = leftTouch.startX + dx;
                        leftTouch.thumb.y = leftTouch.startY + dy;
                        moveJoy.deltaX = dx / max;
                        moveJoy.deltaY = dy / max;
                    } else {
                        const angle = Math.atan2(dy, dx);
                        leftTouch.thumb.x = leftTouch.startX + Math.cos(angle) * max;
                        leftTouch.thumb.y = leftTouch.startY + Math.sin(angle) * max;
                        moveJoy.deltaX = Math.cos(angle);
                        moveJoy.deltaY = Math.sin(angle);
                    }
                    moveJoy.active = true;
                    
                    // Update glow position
                    leftTouch.glow.x = leftTouch.thumb.x;
                    leftTouch.glow.y = leftTouch.thumb.y;
                }
                
                if (rightTouch && pointer.id === rightTouch.id) {
                    const dx = pointer.x - rightTouch.startX;
                    const dy = pointer.y - rightTouch.startY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const max = 55;
                    
                    if (dist < max) {
                        rightTouch.thumb.x = rightTouch.startX + dx;
                        rightTouch.thumb.y = rightTouch.startY + dy;
                    } else {
                        const angle = Math.atan2(dy, dx);
                        rightTouch.thumb.x = rightTouch.startX + Math.cos(angle) * max;
                        rightTouch.thumb.y = rightTouch.startY + Math.sin(angle) * max;
                    }
                    
                    aimJoy.angle = Math.atan2(dy, dx);
                    aimJoy.active = dist > 15;
                    
                    // Update glow position
                    rightTouch.glow.x = rightTouch.thumb.x;
                    rightTouch.glow.y = rightTouch.thumb.y;
                }
            });
            
            scene.input.on('pointerup', (pointer) => {
                if (leftTouch && pointer.id === leftTouch.id) {
                    leftTouch.base.destroy();
                    leftTouch.thumb.destroy();
                    leftTouch.glow.destroy();
                    leftTouch = null;
                    moveJoy.active = false;
                    moveJoy.deltaX = 0;
                    moveJoy.deltaY = 0;
                }
                
                if (rightTouch && pointer.id === rightTouch.id) {
                    if (aimJoy.active && canAttack && playerStamina >= 20) {
                        shootProjectile(scene, aimJoy.angle);
                    }
                    rightTouch.base.destroy();
                    rightTouch.thumb.destroy();
                    rightTouch.glow.destroy();
                    rightTouch = null;
                    aimJoy.active = false;
                }
            });
        }

        // Dash function (enhanced)
        function performDash(scene) {
            const now = Date.now();
            
            if (now - lastDashTime < DASH_COOLDOWN) {
                if (dashButton) {
                    scene.tweens.add({
                        targets: dashButton.bg,
                        alpha: 0.1,
                        duration: 100,
                        yoyo: true
                    });
                }
                return;
            }
            
            if (playerStamina < DASH_STAMINA_COST) {
                showStaminaWarning(scene);
                
                scene.tweens.add({
                    targets: staminaBar,
                    fillColor: 0xff0000,
                    duration: 100,
                    yoyo: true,
                    onComplete: () => staminaBar.fillColor = 0x1a1a2e
                });
                return;
            }
            
            let dx = 0, dy = 0;
            
            if (isMobile && moveJoy.active) {
                dx = moveJoy.deltaX;
                dy = moveJoy.deltaY;
            } else {
                const angle = Math.atan2(mouseY - player.y, mouseX - player.x);
                dx = Math.cos(angle);
                dy = Math.sin(angle);
            }
            
            if (dx === 0 && dy === 0) {
                dx = 1;
            }
            
            const length = Math.sqrt(dx*dx + dy*dy);
            dx /= length;
            dy /= length;
            
            isDashing = true;
            isInvulnerable = true;
            lastDashTime = now;
            playerStamina -= DASH_STAMINA_COST;
            
            dashDirection.x = dx;
            dashDirection.y = dy;
            dashTimer = 0;
            
            // Epic dash effect
            player.core.setScale(0.8);
            player.ring1.setScale(1.5);
            player.ring2.setScale(1.8);
            
            createDashTrail(scene);
            
            updateStaminaBar();
            
            if (dashButton) {
                dashButton.cooldownOverlay.fillColor = 0xff0000;
                dashButton.cooldownOverlay.fillAlpha = 0.5;
                
                scene.time.delayedCall(DASH_COOLDOWN, () => {
                    dashButton.cooldownOverlay.fillAlpha = 0;
                });
            }
        }

        // Show stamina warning
        function showStaminaWarning(scene) {
            if (staminaWarning) {
                staminaWarning.setVisible(true);
                staminaWarning.setAlpha(1);
                
                scene.tweens.add({
                    targets: staminaWarning,
                    alpha: 0,
                    duration: 1000,
                    ease: 'Power2',
                    onComplete: () => staminaWarning.setVisible(false)
                });
            }
        }

        // Enhanced dash trail
        function createDashTrail(scene) {
            let trailCount = 0;
            const trailInterval = setInterval(() => {
                if (!isDashing || trailCount > 15) {
                    clearInterval(trailInterval);
                    return;
                }
                
                // Create afterimage
                const afterimage = scene.add.container(player.x, player.y);
                
                const core = scene.add.circle(0, 0, 18, 0x00d4ff, 0.5);
                const ring = scene.add.circle(0, 0, 24, 0x00d4ff, 0.3);
                
                afterimage.add([ring, core]);
                afterimage.setDepth(40);
                
                scene.tweens.add({
                    targets: afterimage,
                    alpha: 0,
                    scale: 0.8,
                    duration: 200,
                    ease: 'Power2',
                    onComplete: () => afterimage.destroy()
                });
                
                // Particle trail
                for (let i = 0; i < 3; i++) {
                    const particle = scene.add.circle(
                        player.x + (Math.random() - 0.5) * 20,
                        player.y + (Math.random() - 0.5) * 20,
                        3 + Math.random() * 4,
                        0x88ddff,
                        0.7
                    );
                    
                    scene.tweens.add({
                        targets: particle,
                        alpha: 0,
                        scale: 0.3,
                        x: particle.x + (Math.random() - 0.5) * 40,
                        y: particle.y + (Math.random() - 0.5) * 40,
                        duration: 300,
                        onComplete: () => particle.destroy()
                    });
                }
                
                trailCount++;
            }, 40);
        }

        function update(time, delta) {
            if (playerHealth <= 0 || bossHealth <= 0) {
                handleGameOver(this);
                return;
            }

            const width = this.cameras.main.width;
            const height = this.cameras.main.height;
            const now = Date.now();

            // Handle dash
            if (isDashing) {
                dashTimer += delta;
                
                player.body.setVelocity(
                    dashDirection.x * DASH_SPEED,
                    dashDirection.y * DASH_SPEED
                );
                
                if (dashTimer >= DASH_DURATION) {
                    isDashing = false;
                    isInvulnerable = false;
                    
                    // Restore normal size
                    player.core.setScale(1);
                    player.ring1.setScale(1);
                    player.ring2.setScale(1);
                    
                    // Small exit effect
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const particle = this.add.circle(player.x, player.y, 3, 0x00d4ff, 0.6);
                        
                        this.tweens.add({
                            targets: particle,
                            x: player.x + Math.cos(angle) * 30,
                            y: player.y + Math.sin(angle) * 30,
                            alpha: 0,
                            scale: 0.5,
                            duration: 200,
                            onComplete: () => particle.destroy()
                        });
                    }
                }
            } else {
                // CHANGED: +20% faster movement (300 -> 360)
                const speed = 360;
                let vx = 0, vy = 0;
                
                if (isMobile && moveJoy.active) {
                    vx = moveJoy.deltaX * speed;
                    vy = moveJoy.deltaY * speed;
                }
                
                if (!isMobile && leftMouseDown && !isChargingAttack) {
                    const dx = mouseX - player.x;
                    const dy = mouseY - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 10) {
                        const angle = Math.atan2(dy, dx);
                        vx = Math.cos(angle) * speed;
                        vy = Math.sin(angle) * speed;
                        
                        if (dist < 50) {
                            vx *= (dist / 50);
                            vy *= (dist / 50);
                        }
                    }
                }
                
                player.body.setVelocity(vx, vy);
            }
            
            // Keep player in bounds
            player.x = Phaser.Math.Clamp(player.x, 30, width - 30);
            player.y = Phaser.Math.Clamp(player.y, 30, height - 30);
            
            // Sync glow effects position
            if (boss.glowEffects) {
                boss.glowEffects.forEach(glow => {
                    if (glow) {
                        glow.x = boss.x;
                        glow.y = boss.y;
                    }
                });
            }
            
            // Keep boss in bounds
            if (boss) {
                boss.x = Phaser.Math.Clamp(boss.x, 100, width - 100);
                boss.y = Phaser.Math.Clamp(boss.y, 100, height - 100);
            }
            
            // Update charge indicator
            if (isChargingAttack) {
                chargeLevel = Math.min(1, (now - chargeStartTime) / CHARGE_TIME);
                
                chargeIndicator.clear();
                
                // Draw charge circle with gradient effect
                const radius = 35 + (chargeLevel * 35);
                
                // Outer ring
                chargeIndicator.lineStyle(4, 0xffaa00, 0.8);
                chargeIndicator.strokeCircle(player.x, player.y, radius);
                
                // Inner glow
                chargeIndicator.lineStyle(2, 0xffdd44, 0.4);
                chargeIndicator.strokeCircle(player.x, player.y, radius - 3);
                
                // Fill based on charge
                for (let i = 0; i < 5; i++) {
                    const alpha = 0.1 - (i * 0.02);
                    chargeIndicator.fillStyle(0xffaa00, alpha);
                    chargeIndicator.slice(
                        player.x, player.y,
                        radius - 5 - i,
                        0, Math.PI * 2 * chargeLevel,
                        false
                    );
                    chargeIndicator.fillPath();
                }
            } else {
                chargeIndicator.clear();
            }
            
            // Aim indicator (enhanced)
            if (!isMobile && aimIndicator && !isChargingAttack) {
                aimIndicator.clear();
                
                if (rightMouseDown) {
                    const dx = mouseX - aimStartX;
                    const dy = mouseY - aimStartY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 15) {
                        // Aim line with glow
                        aimIndicator.lineStyle(4, 0xff6666, 0.5);
                        aimIndicator.lineBetween(aimStartX, aimStartY, mouseX, mouseY);
                        
                        aimIndicator.lineStyle(2, 0xff3333, 1);
                        aimIndicator.lineBetween(aimStartX, aimStartY, mouseX, mouseY);
                        
                        // Target circle
                        aimIndicator.lineStyle(3, 0xff3333, 1);
                        aimIndicator.strokeCircle(mouseX, mouseY, 12);
                        
                        aimIndicator.lineStyle(1, 0xff8888, 0.8);
                        aimIndicator.strokeCircle(mouseX, mouseY, 8);
                    }
                }
            }

            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                
                proj.x += proj.vx * (delta / 1000);
                proj.y += proj.vy * (delta / 1000);
                
                const dist = Phaser.Math.Distance.Between(proj.x, proj.y, boss.x, boss.y);
                if (dist < 70) {
                    const damage = proj.damage || 18;
                    hitBoss(this, damage);
                    proj.destroy();
                    projectiles.splice(i, 1);
                    continue;
                }
                
                if (proj.x < -50 || proj.x > width + 50 || proj.y < -50 || proj.y > height + 50) {
                    proj.destroy();
                    projectiles.splice(i, 1);
                }
            }

            // Update boss projectiles
            for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                const bProj = bossProjectiles[i];
                
                bProj.x += bProj.vx * (delta / 1000);
                bProj.y += bProj.vy * (delta / 1000);
                
                const distToPlayer = Phaser.Math.Distance.Between(bProj.x, bProj.y, player.x, player.y);
                if (distToPlayer < 25 && !isInvulnerable) {
                    hitPlayer(this, 10);
                    bProj.destroy();
                    bossProjectiles.splice(i, 1);
                    continue;
                }
                
                if (bProj.x < -50 || bProj.x > width + 50 || bProj.y < -50 || bProj.y > height + 50) {
                    bProj.destroy();
                    bossProjectiles.splice(i, 1);
                }
            }

            // CHANGED: New stamina regen (20% less than 0.225 = 0.18)
            if (playerStamina < 100) {
                playerStamina = Math.min(100, playerStamina + 0.18);
                updateStaminaBar();
            }

            // CHANGED: Boss AI attacks 20% faster
            if (time > bossNextAttackTime) {
                bossNextAttackTime = time + Phaser.Math.Between(1600, 2800); // Was 2000-3500
                bossAttack(this);
            }

            updateHealthBars();
        }

        function shootProjectile(scene, angle) {
            if (isDashing || isChargingAttack) return;
            
            canAttack = false;
            playerStamina -= 20;
            
            const speed = 900; // CHANGED: +20% faster (was 750)
            const startX = player.x + Math.cos(angle) * 30;
            const startY = player.y + Math.sin(angle) * 30;
            
            // Enhanced flash
            const flash = scene.add.circle(startX, startY, 25, 0xffffff, 1);
            scene.tweens.add({
                targets: flash,
                scale: 2.5,
                alpha: 0,
                duration: 150,
                onComplete: () => flash.destroy()
            });
            
            // Projectile container
            const proj = scene.add.container(startX, startY);
            
            const core = scene.add.circle(0, 0, 8, 0xffffff);
            const glow = scene.add.circle(0, 0, 12, 0x66ffff, 0.8);
            const outerGlow = scene.add.circle(0, 0, 18, 0x66ffff, 0.3);
            
            proj.add([outerGlow, glow, core]);
            proj.setDepth(150);
            
            proj.vx = Math.cos(angle) * speed;
            proj.vy = Math.sin(angle) * speed;
            
            projectiles.push(proj);
            
            // Trail
            let trailCount = 0;
            const trailInterval = setInterval(() => {
                if (!proj.scene || trailCount > 20) {
                    clearInterval(trailInterval);
                    return;
                }
                
                const trail = scene.add.circle(proj.x, proj.y, 8, 0x66ffff, 0.5);
                trail.setDepth(148);
                
                scene.tweens.add({
                    targets: trail,
                    alpha: 0,
                    scale: 0.5,
                    duration: 200,
                    onComplete: () => trail.destroy()
                });
                
                trailCount++;
            }, 40);
            
            scene.time.delayedCall(400, () => canAttack = true);
        }

        function bossAttack(scene) {
            if (currentBossId === 1) boss1Attack(scene);
            else if (currentBossId === 2) boss2Attack(scene);
            else if (currentBossId === 3) boss3Attack(scene);
        }

        function boss1Attack(scene) {
            // Enhanced warning
            const warning = scene.add.rectangle(boss.x - 100, boss.y, 180, 150, 0xff0051, 0.3);
            warning.setStrokeStyle(4, 0xff3366);
            
            scene.tweens.add({
                targets: warning,
                alpha: 0.6,
                duration: 600,
                yoyo: true,
                onComplete: () => {
                    warning.destroy();
                    
                    const slashZone = scene.add.rectangle(boss.x - 100, boss.y, 180, 150, 0xff6666, 0.8);
                    
                    // Slash effect
                    for (let i = 0; i < 10; i++) {
                        const slash = scene.add.rectangle(
                            boss.x - 100 + (Math.random() - 0.5) * 150,
                            boss.y + (Math.random() - 0.5) * 120,
                            20,
                            5,
                            0xff8888,
                            0.6
                        );
                        
                        scene.tweens.add({
                            targets: slash,
                            alpha: 0,
                            scaleX: 3,
                            duration: 200,
                            onComplete: () => slash.destroy()
                        });
                    }
                    
                    const dist = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
                    if (dist < 120 && !isInvulnerable) {
                        hitPlayer(scene, 15);
                    }
                    
                    scene.tweens.add({
                        targets: slashZone,
                        alpha: 0,
                        duration: 150,
                        onComplete: () => slashZone.destroy()
                    });
                }
            });
        }

        function boss2Attack(scene) {
            const warning = scene.add.circle(boss.x, boss.y, 45, 0xff6600, 0.3);
            warning.setStrokeStyle(4, 0xff8833);
            
            scene.tweens.add({
                targets: warning,
                radius: 65,
                alpha: 0,
                duration: 600,
                onComplete: () => {
                    warning.destroy();
                    
                    const angleToPlayer = Math.atan2(player.y - boss.y, player.x - boss.x);
                    const spread = Math.PI / 3;
                    
                    // Muzzle flash
                    const flash = scene.add.circle(boss.x, boss.y, 30, 0xff6600, 0.8);
                    scene.tweens.add({
                        targets: flash,
                        scale: 2,
                        alpha: 0,
                        duration: 150,
                        onComplete: () => flash.destroy()
                    });
                    
                    for (let i = -2; i <= 2; i++) {
                        const angle = angleToPlayer + (i * spread / 4);
                        const bossProj = scene.add.circle(boss.x, boss.y, 10, 0xff6600);
                        bossProj.setDepth(150);
                        bossProj.vx = Math.cos(angle) * 350; // CHANGED: +16% faster (was 300)
                        bossProj.vy = Math.sin(angle) * 350;
                        bossProj.isBossProj = true;
                        
                        // Add glow
                        const glow = scene.add.circle(boss.x, boss.y, 16, 0xff6600, 0.4);
                        glow.setDepth(149);
                        bossProj.glow = glow;
                        
                        bossProjectiles.push(bossProj);
                        
                        scene.time.delayedCall(2500, () => {
                            if (bossProj.scene) {
                                if (bossProj.glow) bossProj.glow.destroy();
                                const idx = bossProjectiles.indexOf(bossProj);
                                if (idx > -1) bossProjectiles.splice(idx, 1);
                                bossProj.destroy();
                            }
                        });
                    }
                }
            });
        }

        function boss3Attack(scene) {
            const targetX = player.x;
            const targetY = player.y;
            
            // Enhanced telegraph
            const line = scene.add.line(0, 0, boss.x, boss.y, targetX, targetY, 0xcc00ff, 0.7);
            line.setLineWidth(8);
            
            // Warning circles along the path
            const warnings = [];
            for (let i = 0.2; i <= 1; i += 0.2) {
                const warnX = boss.x + (targetX - boss.x) * i;
                const warnY = boss.y + (targetY - boss.y) * i;
                const warn = scene.add.circle(warnX, warnY, 20, 0xcc00ff, 0.3);
                warn.setStrokeStyle(2, 0xdd33ff);
                warnings.push(warn);
            }
            
            scene.tweens.add({
                targets: [...warnings, line],
                alpha: 0,
                duration: 500,
                onComplete: () => {
                    line.destroy();
                    warnings.forEach(w => w.destroy());
                    
                    // Dash effect
                    const startX = boss.x;
                    const startY = boss.y;
                    
                    scene.tweens.add({
                        targets: boss,
                        x: targetX,
                        y: targetY,
                        duration: 120, // CHANGED: 20% faster (was 150)
                        ease: 'Power3',
                        onUpdate: () => {
                            // Trail during dash
                            if (Math.random() > 0.5) {
                                const trail = scene.add.circle(boss.x, boss.y, 15, 0xcc00ff, 0.4);
                                scene.tweens.add({
                                    targets: trail,
                                    alpha: 0,
                                    scale: 0.5,
                                    duration: 200,
                                    onComplete: () => trail.destroy()
                                });
                            }
                        },
                        onComplete: () => {
                            const dist = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
                            if (dist < 70 && !isInvulnerable) {
                                hitPlayer(scene, 20);
                                
                                // Impact effect
                                for (let i = 0; i < 12; i++) {
                                    const angle = (i / 12) * Math.PI * 2;
                                    const particle = scene.add.circle(boss.x, boss.y, 5, 0xcc00ff, 0.8);
                                    
                                    scene.tweens.add({
                                        targets: particle,
                                        x: boss.x + Math.cos(angle) * 50,
                                        y: boss.y + Math.sin(angle) * 50,
                                        alpha: 0,
                                        duration: 300,
                                        onComplete: () => particle.destroy()
                                    });
                                }
                            }
                            
                            scene.cameras.main.shake(100, 0.005);
                        }
                    });
                }
            });
        }

        function hitBoss(scene, damage) {
            bossHealth = Math.max(0, bossHealth - damage);
            
            scene.physics.pause();
            scene.time.delayedCall(30, () => scene.physics.resume()); // Slightly shorter freeze
            
            // Enhanced hit effect
            const flash = scene.add.rectangle(boss.x, boss.y, 120, 160, 0xffffff, 0.9);
            flash.setDepth(200);
            scene.tweens.add({
                targets: flash,
                alpha: 0,
                scale: 1.2,
                duration: 80,
                onComplete: () => flash.destroy()
            });
            
            scene.tweens.add({ targets: boss, alpha: 0.2, duration: 50, yoyo: true });
            
            // Damage number with glow
            const dmgText = scene.add.text(boss.x, boss.y - 50, damage.toString(), {
                fontSize: Math.min(28, scene.cameras.main.height * 0.035) + 'px',
                fill: '#ffaa00',
                stroke: '#000',
                strokeThickness: 6,
                fontStyle: 'bold',
                shadow: {
                    offsetX: 0,
                    offsetY: 0,
                    color: '#ff0000',
                    blur: 8,
                    fill: true
                }
            }).setOrigin(0.5);
            
            scene.tweens.add({
                targets: dmgText,
                y: boss.y - 120,
                alpha: 0,
                scale: 1.5,
                duration: 600,
                ease: 'Power2',
                onComplete: () => dmgText.destroy()
            });
            
            bossData = BOSSES[currentBossId];
            
            // Enhanced particle explosion
            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 * i) / 30;
                const dist = Phaser.Math.Between(30, 90);
                const size = Phaser.Math.Between(4, 12);
                
                const p = scene.add.circle(boss.x, boss.y, size, bossData.glowColor);
                p.setDepth(199);
                
                scene.tweens.add({
                    targets: p,
                    x: boss.x + Math.cos(angle) * dist,
                    y: boss.y + Math.sin(angle) * dist,
                    alpha: 0,
                    scale: 0.3,
                    duration: 500,
                    ease: 'Power2',
                    onComplete: () => p.destroy()
                });
            }
            
            // Shockwave ring
            const ring = scene.add.circle(boss.x, boss.y, 30, bossData.glowColor, 0);
            ring.setStrokeStyle(5, bossData.glowColor, 0.9);
            ring.setDepth(198);
            scene.tweens.add({
                targets: ring,
                radius: 150,
                alpha: 0,
                duration: 350,
                ease: 'Power2',
                onComplete: () => ring.destroy()
            });
            
            scene.cameras.main.shake(60, 0.005);
            
            if (bossHealth <= 0) {
                scene.time.timeScale = 0.2;
                scene.time.delayedCall(300, () => {
                    scene.time.timeScale = 1;
                });
            }
        }

        function hitPlayer(scene, damage) {
            if (isInvulnerable) return;
            
            playerHealth = Math.max(0, playerHealth - damage);
            
            const flash = scene.add.rectangle(player.x, player.y, 70, 70, 0xff0000, 0.7);
            flash.setDepth(200);
            scene.tweens.add({
                targets: flash,
                alpha: 0,
                scale: 1.5,
                duration: 120,
                onComplete: () => flash.destroy()
            });
            
            scene.tweens.add({ targets: player, alpha: 0.3, duration: 60, yoyo: true, repeat: 1 });
            
            for (let i = 0; i < 12; i++) {
                const angle = Phaser.Math.Between(0, 360) * Math.PI / 180;
                const p = scene.add.circle(player.x, player.y, 6, 0xff3355);
                scene.tweens.add({
                    targets: p,
                    x: player.x + Math.cos(angle) * 50,
                    y: player.y + Math.sin(angle) * 50,
                    alpha: 0,
                    duration: 300,
                    onComplete: () => p.destroy()
                });
            }
            
            scene.cameras.main.shake(80, 0.006);
        }

        function updateHealthBars() {
            playerHealthText.width = (playerHealthBar.width) * (playerHealth / 100);
            bossHealthText.width = (bossHealthBar.width) * (bossHealth / BOSSES[currentBossId].hp);
            
            if (playerHealth < 30) playerHealthText.fillColor = 0xff0000;
            else if (playerHealth < 60) playerHealthText.fillColor = 0xffaa00;
            else playerHealthText.fillColor = 0x00ff88;
        }

        function updateStaminaBar() {
            staminaText.width = staminaBar.width * (playerStamina / 100);
        }

        function handleGameOver(scene) {
            const width = scene.cameras.main.width;
            const height = scene.cameras.main.height;
            
            scene.physics.pause();
            const isVictory = bossHealth <= 0;
            const msg = isVictory ? 'âœ¨ VICTORY âœ¨' : 'ðŸ’€ DEFEAT ðŸ’€';
            const color = isVictory ? '#00ff88' : '#ff3355';
            
            if (isVictory && currentBossId === unlockedBosses && currentBossId < 3) {
                unlockedBosses++;
                localStorage.setItem('unlockedBosses', unlockedBosses);
            }
            
            // Epic victory/defeat text
            const txt = scene.add.text(width * 0.5, height * 0.4, msg, { 
                fontSize: Math.min(72, height * 0.12) + 'px', 
                fill: color, 
                fontStyle: 'bold', 
                stroke: '#fff', 
                strokeThickness: 4,
                shadow: {
                    offsetX: 0,
                    offsetY: 0,
                    color: color,
                    blur: 20,
                    fill: true
                }
            }).setOrigin(0.5);
            
            scene.tweens.add({ 
                targets: txt, 
                scale: 1.2, 
                duration: 600, 
                yoyo: true, 
                repeat: -1,
                ease: 'Sine.easeInOut'
            });
            
            if (isVictory) {
                scene.add.text(width * 0.5, height * 0.5, BOSSES[currentBossId].name + ' DEFEATED!', {
                    fontSize: Math.min(24, height * 0.035) + 'px',
                    fill: '#888',
                    stroke: '#000',
                    strokeThickness: 2
                }).setOrigin(0.5);
            }
            
            // Buttons with enhanced style
            const retryBtn = scene.add.text(width * 0.4, height * 0.6, '[ RETRY ]', { 
                fontSize: Math.min(26, height * 0.04) + 'px', 
                fill: '#00d4ff', 
                backgroundColor: '#00000099', 
                padding: { x: 25, y: 12 },
                stroke: '#88ddff',
                strokeThickness: 1
            }).setOrigin(0.5).setInteractive({ useHandCursor: true });
            
            retryBtn.on('pointerover', () => retryBtn.setScale(1.1));
            retryBtn.on('pointerout', () => retryBtn.setScale(1));
            retryBtn.on('pointerdown', () => {
                scene.scene.restart();
                playerHealth = 100;
                bossHealth = BOSSES[currentBossId].hp;
                playerStamina = 100;
                projectiles = [];
                bossProjectiles = [];
            });
            
            const selectBtn = scene.add.text(width * 0.6, height * 0.6, '[ SELECT BOSS ]', { 
                fontSize: Math.min(26, height * 0.04) + 'px', 
                fill: '#ff6600', 
                backgroundColor: '#00000099', 
                padding: { x: 25, y: 12 },
                stroke: '#ff8833',
                strokeThickness: 1
            }).setOrigin(0.5).setInteractive({ useHandCursor: true });
            
            selectBtn.on('pointerover', () => selectBtn.setScale(1.1));
            selectBtn.on('pointerout', () => selectBtn.setScale(1));
            selectBtn.on('pointerdown', () => showBossSelect(scene));
            
            if (isVictory && currentBossId < unlockedBosses) {
                const nextBtn = scene.add.text(width * 0.5, height * 0.7, 'â†’ NEXT BOSS â†', { 
                    fontSize: Math.min(22, height * 0.035) + 'px', 
                    fill: '#00ff88', 
                    backgroundColor: '#00000099', 
                    padding: { x: 20, y: 10 },
                    stroke: '#88ffaa',
                    strokeThickness: 1
                }).setOrigin(0.5).setInteractive({ useHandCursor: true });
                
                nextBtn.on('pointerover', () => nextBtn.setScale(1.1));
                nextBtn.on('pointerout', () => nextBtn.setScale(1));
                nextBtn.on('pointerdown', () => {
                    currentBossId++;
                    localStorage.setItem('currentBoss', currentBossId);
                    scene.scene.restart();
                    playerHealth = 100;
                    bossHealth = BOSSES[currentBossId].hp;
                    playerStamina = 100;
                    projectiles = [];
                    bossProjectiles = [];
                });
            }
        }

        function showBossSelect(scene) {
            const width = scene.cameras.main.width;
            const height = scene.cameras.main.height;
            
            scene.children.removeAll();
            
            scene.add.text(width * 0.5, height * 0.1, 'SELECT BOSS', {
                fontSize: Math.min(54, height * 0.09) + 'px',
                fill: '#00d4ff',
                fontStyle: 'bold',
                stroke: '#fff',
                strokeThickness: 2,
                shadow: {
                    offsetX: 0,
                    offsetY: 0,
                    color: '#00d4ff',
                    blur: 15,
                    fill: true
                }
            }).setOrigin(0.5);
            
            const startX = width * 0.2;
            const spacing = width * 0.25;
            
            [1, 2, 3].forEach((bossId, index) => {
                const bossData = BOSSES[bossId];
                const x = startX + (index * spacing);
                const y = height * 0.5;
                const unlocked = bossId <= unlockedBosses;
                
                // Card with glow
                const card = scene.add.rectangle(x, y, width * 0.18, height * 0.35, 0x1a1a2e, unlocked ? 0.9 : 0.4);
                card.setStrokeStyle(4, bossData.color, unlocked ? 1 : 0.3);
                
                if (unlocked) {
                    card.setInteractive({ useHandCursor: true });
                    
                    card.on('pointerover', () => {
                        scene.tweens.add({ 
                            targets: card, 
                            scaleX: 1.08, 
                            scaleY: 1.08, 
                            duration: 200,
                            ease: 'Power2'
                        });
                    });
                    
                    card.on('pointerout', () => {
                        scene.tweens.add({ 
                            targets: card, 
                            scaleX: 1, 
                            scaleY: 1, 
                            duration: 200,
                            ease: 'Power2'
                        });
                    });
                    
                    card.on('pointerdown', () => {
                        currentBossId = bossId;
                        localStorage.setItem('currentBoss', currentBossId);
                        scene.scene.restart();
                        playerHealth = 100;
                        bossHealth = BOSSES[currentBossId].hp;
                        playerStamina = 100;
                        projectiles = [];
                        bossProjectiles = [];
                    });
                }
                
                // Boss preview with glow
                const preview = scene.add.circle(x, y - height * 0.08, height * 0.06, bossData.color, unlocked ? 1 : 0.3);
                const glow = scene.add.circle(x, y - height * 0.08, height * 0.08, bossData.glowColor, unlocked ? 0.3 : 0.1);
                
                scene.add.text(x, y + height * 0.05, bossData.name, {
                    fontSize: Math.min(20, height * 0.028) + 'px',
                    fill: unlocked ? '#fff' : '#444',
                    fontStyle: 'bold'
                }).setOrigin(0.5);
                
                scene.add.text(x, y + height * 0.12, 'HP: ' + bossData.hp, {
                    fontSize: Math.min(16, height * 0.022) + 'px',
                    fill: unlocked ? '#ffaa00' : '#333'
                }).setOrigin(0.5);
                
                if (!unlocked) {
                    scene.add.text(x, y, 'ðŸ”’', { 
                        fontSize: Math.min(40, height * 0.05) + 'px',
                        stroke: '#000',
                        strokeThickness: 2
                    }).setOrigin(0.5);
                }
            });
            
            // Back button
            const backBtn = scene.add.text(width * 0.5, height * 0.85, '[ BACK TO GAME ]', { 
                fontSize: Math.min(20, height * 0.03) + 'px', 
                fill: '#aaa', 
                backgroundColor: '#00000099', 
                padding: { x: 20, y: 10 }
            }).setOrigin(0.5).setInteractive({ useHandCursor: true });
            
            backBtn.on('pointerover', () => backBtn.setScale(1.1));
            backBtn.on('pointerout', () => backBtn.setScale(1));
            backBtn.on('pointerdown', () => {
                scene.scene.restart();
                playerHealth = 100;
                bossHealth = BOSSES[currentBossId].hp;
                playerStamina = 100;
                projectiles = [];
                bossProjectiles = [];
            });
        }

        window.addEventListener('load', () => { 
            game = new Phaser.Game(config); 
        });
    </script>
</body>
</html>