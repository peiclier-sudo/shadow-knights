<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Boss Rush Soulslike - Combats épiques en 2D">
    <title>Shadow Knights - Boss Rush</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a1a 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
        }
        #game-container {
            box-shadow: 0 0 40px rgba(255,0,80,0.5);
            border-radius: 8px;
            overflow: hidden;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            text-align: center;
        }
        .spinner {
            border: 4px solid rgba(255,255,255,0.1);
            border-top: 4px solid #ff0051;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        Chargement...
    </div>
    <div id="game-container"></div>
    <script>
        // Configuration du jeu
        const config = {
            type: Phaser.AUTO,
            width: 1000,
            height: 700,
            parent: 'game-container',
            backgroundColor: '#0a0a1a',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };

        let game;
        let player, boss;
        let cursors, keys;
        let playerHealth = 100, bossHealth = 400;
        let playerStamina = 100;
        let isDodging = false, isAttacking = false, isCasting = false;
        let canDodge = true, canAttack = true;
        
        // Projectiles
        let projectiles;
        let bossWarnings;
        
        // UI elements
        let playerHealthBar, bossHealthBar, staminaBar;
        let playerHealthText, bossHealthText, staminaText;
        
        // Mobile controls
        let virtualJoystick, attackButton, dodgeButton, rangedButton;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Boss AI
        let bossState = 'idle';
        let bossAttackTimer = 0;
        let bossPattern = 0;
        let bossNextAttack = 3000; // Premier délai
        
        // Stats pour progression
        let gamesPlayed = 0;
        let victories = 0;
        
        // Particules
        let particles;

        function preload() {
            // Cacher le loading screen
            document.getElementById('loading').style.display = 'none';
            
            // Charger les stats depuis localStorage
            const savedStats = localStorage.getItem('soulslike-stats');
            if (savedStats) {
                const stats = JSON.parse(savedStats);
                gamesPlayed = stats.gamesPlayed || 0;
                victories = stats.victories || 0;
            }
        }

        function create() {
            // Fond avec grille pour meilleure profondeur
            const graphics = this.add.graphics();
            graphics.lineStyle(1, 0x2a2a3e, 0.3);
            for (let i = 0; i < 1000; i += 50) {
                graphics.lineBetween(i, 0, i, 700);
            }
            for (let i = 0; i < 700; i += 50) {
                graphics.lineBetween(0, i, 1000, i);
            }
            
            // Créer le joueur (cercle bleu lumineux)
            player = this.add.circle(150, 350, 20, 0x00d4ff);
            this.physics.add.existing(player);
            player.body.setCollideWorldBounds(true);
            player.direction = 1;
            player.invulnerable = false;
            
            // Glow effect joueur
            const playerGlow = this.add.circle(150, 350, 30, 0x00d4ff, 0.2);
            player.glow = playerGlow;
            
            // Créer le boss (plus imposant et menaçant)
            boss = this.add.container(850, 350);
            const bossBody = this.add.rectangle(0, 0, 60, 90, 0xff0051);
            const bossHead = this.add.circle(0, -50, 25, 0xff0051);
            const bossEyeL = this.add.circle(-10, -55, 4, 0xff6666);
            const bossEyeR = this.add.circle(10, -55, 4, 0xff6666);
            boss.add([bossBody, bossHead, bossEyeL, bossEyeR]);
            
            this.physics.add.existing(boss);
            boss.body.setSize(60, 115);
            boss.body.setCollideWorldBounds(true);
            boss.body.immovable = true;
            boss.nextAttackTime = 0;
            
            // Glow boss
            const bossGlow = this.add.circle(850, 350, 80, 0xff0051, 0.15);
            boss.glow = bossGlow;
            
            // Groups pour projectiles
            projectiles = this.physics.add.group();
            bossWarnings = this.add.group();
            
            // Contrôles clavier
            cursors = this.input.keyboard.createCursorKeys();
            keys = {
                space: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE),
                shift: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT),
                E: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E),
                Z: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Z),
                Q: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q),
                S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),
                D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)
            };
            
            // UI - Barres de vie
            const barWidth = 350;
            const barHeight = 25;
            
            // Barre de vie joueur
            this.add.text(20, 20, 'CHEVALIER', { fontSize: '18px', fill: '#00d4ff', fontStyle: 'bold' });
            playerHealthBar = this.add.rectangle(20, 55, barWidth, barHeight, 0x1a1a2e);
            playerHealthBar.setOrigin(0, 0.5);
            playerHealthBar.setStrokeStyle(2, 0x333344);
            playerHealthText = this.add.rectangle(20, 55, barWidth, barHeight, 0x00ff88);
            playerHealthText.setOrigin(0, 0.5);
            
            // Barre de stamina
            this.add.text(20, 82, 'STAMINA', { fontSize: '14px', fill: '#ffaa00' });
            staminaBar = this.add.rectangle(20, 105, barWidth * 0.7, 15, 0x1a1a2e);
            staminaBar.setOrigin(0, 0.5);
            staminaBar.setStrokeStyle(2, 0x333344);
            staminaText = this.add.rectangle(20, 105, barWidth * 0.7, 15, 0xffaa00);
            staminaText.setOrigin(0, 0.5);
            
            // Barre de vie boss
            this.add.text(630, 20, 'SEIGNEUR DES OMBRES', { fontSize: '20px', fill: '#ff0051', fontStyle: 'bold' });
            bossHealthBar = this.add.rectangle(630, 60, barWidth, barHeight, 0x1a1a2e);
            bossHealthBar.setOrigin(0, 0.5);
            bossHealthBar.setStrokeStyle(2, 0x333344);
            bossHealthText = this.add.rectangle(630, 60, barWidth, barHeight, 0xff0051);
            bossHealthText.setOrigin(0, 0.5);
            
            // Stats en bas
            this.add.text(980, 680, `Parties: ${gamesPlayed} | Victoires: ${victories}`, {
                fontSize: '12px',
                fill: '#666',
                align: 'right'
            }).setOrigin(1, 0);
            
            // Contrôles mobiles
            if (isMobile) {
                createMobileControls(this);
            }
            
            // Instructions
            const instructions = isMobile 
                ? 'Joystick: Bouger | ATK: Mêlée | RANGE: Distance | ROLL: Esquiver'
                : 'ZQSD/Flèches: Bouger | ESPACE: Mêlée | E: Distance | SHIFT: Esquiver';
            this.add.text(500, 680, instructions, { 
                fontSize: '13px', 
                fill: '#888',
                backgroundColor: '#00000066',
                padding: { x: 12, y: 6 }
            }).setOrigin(0.5);
        }

        function createMobileControls(scene) {
            // Virtual Joystick (gauche)
            const joystickBase = scene.add.circle(100, 500, 50, 0x333333, 0.5);
            const joystickThumb = scene.add.circle(100, 500, 25, 0x00d4ff, 0.8);
            
            virtualJoystick = {
                base: joystickBase,
                thumb: joystickThumb,
                active: false,
                startX: 100,
                startY: 500,
                deltaX: 0,
                deltaY: 0
            };
            
            joystickBase.setInteractive();
            joystickBase.on('pointerdown', function(pointer) {
                virtualJoystick.active = true;
            });
            
            scene.input.on('pointermove', function(pointer) {
                if (virtualJoystick.active && pointer.isDown) {
                    const dx = pointer.x - virtualJoystick.startX;
                    const dy = pointer.y - virtualJoystick.startY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const maxDistance = 50;
                    
                    if (distance < maxDistance) {
                        virtualJoystick.thumb.x = virtualJoystick.startX + dx;
                        virtualJoystick.thumb.y = virtualJoystick.startY + dy;
                        virtualJoystick.deltaX = dx / maxDistance;
                        virtualJoystick.deltaY = dy / maxDistance;
                    } else {
                        const angle = Math.atan2(dy, dx);
                        virtualJoystick.thumb.x = virtualJoystick.startX + Math.cos(angle) * maxDistance;
                        virtualJoystick.thumb.y = virtualJoystick.startY + Math.sin(angle) * maxDistance;
                        virtualJoystick.deltaX = Math.cos(angle);
                        virtualJoystick.deltaY = Math.sin(angle);
                    }
                }
            });
            
            scene.input.on('pointerup', function() {
                virtualJoystick.active = false;
                virtualJoystick.thumb.x = virtualJoystick.startX;
                virtualJoystick.thumb.y = virtualJoystick.startY;
                virtualJoystick.deltaX = 0;
                virtualJoystick.deltaY = 0;
            });
            
            // Bouton d'attaque (droite)
            attackButton = scene.add.circle(650, 500, 40, 0xff6b6b, 0.7);
            attackButton.setInteractive();
            const attackText = scene.add.text(650, 500, 'ATK', { fontSize: '16px', fill: '#fff', fontStyle: 'bold' });
            attackText.setOrigin(0.5);
            
            attackButton.on('pointerdown', function() {
                if (canAttack && !isDodging && playerStamina >= 20) {
                    performAttack(scene);
                }
            });
            
            // Bouton d'esquive
            dodgeButton = scene.add.circle(730, 450, 35, 0x00d4ff, 0.7);
            dodgeButton.setInteractive();
            const dodgeText = scene.add.text(730, 450, 'ROLL', { fontSize: '14px', fill: '#fff', fontStyle: 'bold' });
            dodgeText.setOrigin(0.5);
            
            dodgeButton.on('pointerdown', function() {
                if (canDodge && !isAttacking && playerStamina >= 25) {
                    performDodge(scene);
                }
            });
        }

        function update(time, delta) {
            if (playerHealth <= 0 || bossHealth <= 0) {
                handleGameOver(this);
                return;
            }
            
            // Mouvement du joueur
            let velocityX = 0;
            let velocityY = 0;
            const speed = isDodging ? 400 : 200;
            
            // Contrôles clavier
            if (cursors.left.isDown || keys.Q.isDown) {
                velocityX = -speed;
                player.direction = -1;
            } else if (cursors.right.isDown || keys.D.isDown) {
                velocityX = speed;
                player.direction = 1;
            }
            
            if (cursors.up.isDown || keys.Z.isDown) {
                velocityY = -speed;
            } else if (cursors.down.isDown || keys.S.isDown) {
                velocityY = speed;
            }
            
            // Contrôles mobiles
            if (virtualJoystick && virtualJoystick.active) {
                velocityX = virtualJoystick.deltaX * speed;
                velocityY = virtualJoystick.deltaY * speed;
                if (velocityX !== 0) {
                    player.direction = velocityX > 0 ? 1 : -1;
                }
            }
            
            player.body.setVelocity(velocityX, velocityY);
            
            // Attaque (clavier)
            if (Phaser.Input.Keyboard.JustDown(keys.space) && canAttack && !isDodging && playerStamina >= 20) {
                performAttack(this);
            }
            
            // Esquive (clavier)
            if (Phaser.Input.Keyboard.JustDown(keys.shift) && canDodge && !isAttacking && playerStamina >= 25) {
                performDodge(this);
            }
            
            // Régénération stamina
            if (playerStamina < 100 && !isAttacking && !isDodging) {
                playerStamina = Math.min(100, playerStamina + 0.3);
                updateStaminaBar();
            }
            
            // IA du Boss
            updateBossAI(this, time, delta);
            
            // Mise à jour UI
            updateHealthBars();
        }

        function performAttack(scene) {
            isAttacking = true;
            canAttack = false;
            playerStamina -= 20;
            
            // Animation d'attaque (dash avant)
            scene.tweens.add({
                targets: player,
                x: player.x + (player.direction * 60),
                duration: 100,
                yoyo: true,
                onComplete: () => {
                    isAttacking = false;
                }
            });
            
            // Flash de l'arme
            const weapon = scene.add.rectangle(
                player.x + (player.direction * 40), 
                player.y, 
                30, 
                10, 
                0xffff00
            );
            scene.tweens.add({
                targets: weapon,
                alpha: 0,
                duration: 150,
                onComplete: () => weapon.destroy()
            });
            
            // Vérifier si on touche le boss
            const distance = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
            if (distance < 100) {
                hitBoss(scene, 15);
            }
            
            // Cooldown
            scene.time.delayedCall(400, () => {
                canAttack = true;
            });
        }

        function performDodge(scene) {
            isDodging = true;
            canDodge = false;
            playerStamina -= 25;
            
            // Invincibilité
            player.alpha = 0.4;
            
            // Dash
            const dashDistance = 100;
            const dashX = cursors.left.isDown || keys.Q.isDown ? -dashDistance : 
                         cursors.right.isDown || keys.D.isDown ? dashDistance : 
                         player.direction * dashDistance;
            const dashY = cursors.up.isDown || keys.Z.isDown ? -dashDistance : 
                         cursors.down.isDown || keys.S.isDown ? dashDistance : 0;
            
            scene.tweens.add({
                targets: player,
                x: player.x + dashX,
                y: player.y + dashY,
                duration: 200,
                ease: 'Power2',
                onComplete: () => {
                    isDodging = false;
                    player.alpha = 1;
                }
            });
            
            // Trail effect
            for (let i = 0; i < 5; i++) {
                scene.time.delayedCall(i * 40, () => {
                    const trail = scene.add.rectangle(player.x, player.y, 40, 40, 0x00d4ff, 0.3);
                    scene.tweens.add({
                        targets: trail,
                        alpha: 0,
                        duration: 200,
                        onComplete: () => trail.destroy()
                    });
                });
            }
            
            // Cooldown
            scene.time.delayedCall(800, () => {
                canDodge = true;
            });
        }

        function updateBossAI(scene, time, delta) {
            bossAttackTimer += delta;
            
            // Pattern d'attaque toutes les 2-3 secondes
            if (bossAttackTimer > 2000 + Math.random() * 1000) {
                bossAttackTimer = 0;
                bossPattern = Math.floor(Math.random() * 3);
                executeBossAttack(scene);
            }
            
            // Boss regarde le joueur
            if (player.x < boss.x) {
                boss.scaleX = -1;
            } else {
                boss.scaleX = 1;
            }
        }

        function executeBossAttack(scene) {
            switch(bossPattern) {
                case 0: // Slash horizontal
                    bossSlashAttack(scene);
                    break;
                case 1: // Charge
                    bossChargeAttack(scene);
                    break;
                case 2: // AOE
                    bossAOEAttack(scene);
                    break;
            }
        }

        function bossSlashAttack(scene) {
            // Animation de préparation
            scene.tweens.add({
                targets: boss,
                scaleX: boss.scaleX * 1.2,
                scaleY: 1.2,
                duration: 300,
                yoyo: true
            });
            
            scene.time.delayedCall(400, () => {
                // Zone d'attaque devant le boss
                boss.attackZone.x = boss.x + (boss.scaleX > 0 ? 100 : -100);
                boss.attackZone.y = boss.y;
                boss.attackZone.setAlpha(0.5);
                boss.attackZone.active = true;
                
                scene.tweens.add({
                    targets: boss.attackZone,
                    alpha: 0,
                    duration: 300,
                    onComplete: () => {
                        boss.attackZone.active = false;
                    }
                });
            });
        }

        function bossChargeAttack(scene) {
            const targetX = player.x;
            
            scene.tweens.add({
                targets: boss,
                x: targetX,
                duration: 400,
                ease: 'Power2',
                onStart: () => {
                    boss.fillColor = 0xff6666;
                    boss.attackZone.x = boss.x;
                    boss.attackZone.y = boss.y;
                    boss.attackZone.width = 100;
                    boss.attackZone.height = 120;
                    boss.attackZone.setAlpha(0.3);
                    boss.attackZone.active = true;
                },
                onComplete: () => {
                    boss.fillColor = 0xff0051;
                    boss.attackZone.active = false;
                    boss.attackZone.setAlpha(0);
                    
                    // Screen shake
                    scene.cameras.main.shake(200, 0.005);
                }
            });
        }

        function bossAOEAttack(scene) {
            // Cercle d'attaque autour du boss
            const aoeCircle = scene.add.circle(boss.x, boss.y, 30, 0xff0051, 0.3);
            
            scene.tweens.add({
                targets: aoeCircle,
                radius: 150,
                alpha: 0,
                duration: 800,
                onUpdate: () => {
                    const distance = Phaser.Math.Distance.Between(player.x, player.y, boss.x, boss.y);
                    if (distance < aoeCircle.radius && !isDodging && aoeCircle.alpha > 0.1) {
                        hitPlayer();
                        aoeCircle.alpha = 0;
                    }
                },
                onComplete: () => aoeCircle.destroy()
            });
        }

        function hitBoss(scene, damage) {
            bossHealth = Math.max(0, bossHealth - damage);
            
            // Flash rouge
            scene.tweens.add({
                targets: boss,
                fillColor: 0xffffff,
                duration: 100,
                yoyo: true
            });
            
            // Particules
            createHitParticles(scene, boss.x, boss.y, 0xff0051);
            
            // Screen shake
            scene.cameras.main.shake(100, 0.003);
            
            updateHealthBars();
        }

        function hitPlayer() {
            if (isDodging) return; // Invincible pendant l'esquive
            
            playerHealth = Math.max(0, playerHealth - 10);
            
            // Flash
            game.scene.scenes[0].tweens.add({
                targets: player,
                fillColor: 0xff0000,
                duration: 100,
                yoyo: true
            });
            
            // Particules
            createHitParticles(game.scene.scenes[0], player.x, player.y, 0x00d4ff);
            
            updateHealthBars();
        }

        function createHitParticles(scene, x, y, color) {
            for (let i = 0; i < 8; i++) {
                const particle = scene.add.circle(x, y, 4, color);
                const angle = (Math.PI * 2 * i) / 8;
                
                scene.tweens.add({
                    targets: particle,
                    x: x + Math.cos(angle) * 40,
                    y: y + Math.sin(angle) * 40,
                    alpha: 0,
                    duration: 400,
                    onComplete: () => particle.destroy()
                });
            }
        }

        function updateHealthBars() {
            const playerPercent = playerHealth / 100;
            const bossPercent = bossHealth / 300;
            
            playerHealthText.width = 300 * playerPercent;
            bossHealthText.width = 300 * bossPercent;
            
            // Changement de couleur selon la vie
            if (playerPercent < 0.3) {
                playerHealthText.fillColor = 0xff0000;
            } else if (playerPercent < 0.6) {
                playerHealthText.fillColor = 0xffaa00;
            } else {
                playerHealthText.fillColor = 0x00ff00;
            }
        }

        function updateStaminaBar() {
            const staminaPercent = playerStamina / 100;
            staminaText.width = 180 * staminaPercent;
        }

        function handleGameOver(scene) {
            scene.physics.pause();
            
            gamesPlayed++;
            const isVictory = bossHealth <= 0;
            if (isVictory) victories++;
            
            // Sauvegarder les stats
            localStorage.setItem('soulslike-stats', JSON.stringify({
                gamesPlayed,
                victories
            }));
            
            const message = isVictory ? 'VICTOIRE !' : 'DÉFAITE...';
            const color = isVictory ? '#00ff00' : '#ff0000';
            
            const gameOverText = scene.add.text(400, 300, message, {
                fontSize: '64px',
                fill: color,
                fontStyle: 'bold',
                stroke: '#000',
                strokeThickness: 6
            }).setOrigin(0.5);
            
            scene.tweens.add({
                targets: gameOverText,
                scale: 1.2,
                duration: 500,
                yoyo: true,
                repeat: -1
            });
            
            const winRate = gamesPlayed > 0 ? Math.round((victories / gamesPlayed) * 100) : 0;
            const statsText = scene.add.text(400, 350, `Taux de victoire: ${winRate}% (${victories}/${gamesPlayed})`, {
                fontSize: '18px',
                fill: '#ffffff',
                backgroundColor: '#00000088',
                padding: { x: 15, y: 8 }
            }).setOrigin(0.5);
            
            const restartText = scene.add.text(400, 400, 'Cliquer ou appuyer pour recommencer', {
                fontSize: '20px',
                fill: '#ffffff',
                backgroundColor: '#00000088',
                padding: { x: 20, y: 10 }
            }).setOrigin(0.5);
            
            scene.input.once('pointerdown', () => {
                scene.scene.restart();
                playerHealth = 100;
                bossHealth = 300;
                playerStamina = 100;
            });
            
            scene.input.keyboard.once('keydown', () => {
                scene.scene.restart();
                playerHealth = 100;
                bossHealth = 300;
                playerStamina = 100;
            });
        }

        // Démarrer le jeu
        window.addEventListener('load', () => {
            game = new Phaser.Game(config);
        });
    </script>
</body>
</html>
